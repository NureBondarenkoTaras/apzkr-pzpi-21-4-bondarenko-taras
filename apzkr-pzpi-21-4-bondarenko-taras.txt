Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для моніторингу за перевезенням вантажів  
 
Студень гр. ПЗПІ-21-4               _______________  Бондаренко.Т.А.
                                                                         (підпис) 

Керівник роботи                         _______________  доц.Лещинська.І.О.
                                                                         (підпис) 

    Роботу захищено «__»_________2024 р.
    з оцінкою _________________________


Комісія:                                       _______________  доц.Лещинський.В.О.
                                                                         (підпис) 
                                                     _______________  доц.Лещинський.І.О.
                                                                         (підпис) 

  _______________  ст.викл. Сокорчук І.П.
                                                                         (підпис) 
	

Харків 
2024 р. 
Харківський національний університет радіоелектроніки   

Факультет комп’ютерних наук                         Кафедра програмної інженерії           
Спеціальність 121 – Інженерія програмного забезпечення            
Курс          3          Семестр                                  6                                              _          
Навчальна дисципліна Архітектура програмного забезпечення
ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                          Бондаренку Тарасу Андрійовичу                                         _ 1. Тема роботи: Програмна система для моніторингу за перевезенням вантажів  .                                                 
2.	Термін узгодження завдання курсової роботи «19»   лютого  2024 р.  
3.	Термін здачі закінченої роботи «08»     червня       2024 р.   
4.	Вихідні дані до проєкту: Програмна система має забезпечувати максимальну безпеку даних та швидкодію. Система має мати серверну частину, клієнтську частину, мобільний застосунок та використання Розумного просторою. Система  повинна бути розрахована на масового користувача з елементами адміністрування, забезпечувати  безпеку даних. 
5.	Зміст пояснювальної записки (перелік питань, що належить розробити):   вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки.
6.	Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): діаграма розгортання, діаграма прецедентів, діаграма взаємодії, діаграма діяльності, діаграма компонентів, модель даних, інтерфейс головно сторінки.             
                     





КАЛЕНДАРНИЙ ПЛАН
 
 
№ 	Назва етапу курсової роботи	Термін виконання етапів роботи	Примітка 
1 	Функціональна специфікація
програмного проекту	28.02.2024	Виконано
2 	Проектування програмного
проекту	20.03.2024	 Виконано
3 	Кодування програмного проекту	04.05.2024	 Виконано
4 	Оформлення пояснювальної
записки	29.05.2024	 Виконано
5 	Захист курсової роботи	08.06.2024	 
 
 
Дата видачі завдання «   19   »        лютого           2024 р.   
 
 
Керівник                                                                  доц.Лещинська.І.О.
(підпис) 



Завдання прийняв до виконання  
ст. гр. ПЗПІ-21-4                                                     Бондаренко.Т.А.
                                                                                (підпис) 


РЕФЕРАТ

Пояснювальна записка до курсової роботи: 119 с., 45 рис.,  3 табл., 6 додаток, 7 джерел.
ВІДСТЕЖЕННЯ ВАНТАЖІВ, КАРТА, ЛОГІСТИКА, СИСТЕМА УПРАВЛІННЯ, ТРАНСПОРТ, MICROSOFT VISUAL STUDIO 2022, MONGODB.
Об'єктом дослідження виступають системи відслідковування перевезення вантажів, що забезпечують ефективний контроль за переміщенням вантажів у режимі реального часу. 
Метою курсової роботи є розробка системи, що забезпечує підвищення ефективності управління процесом перевезення вантажів, надає можливість моніторингу їхнього статусу та місцезнаходження. Система забезпечує збереження даних про всі перевезені вантажі, надає можливість відслідковування маршруту, а також впроваджує функціонал для аналізу логістичних операцій. 
Методи розробки базуються на використанні технології ASP.NET Core контролери для серверної частини, MongoDB для бази даних, веб-додаток реалізовано за допомогою бібліотеки React, мобільний додаток – на технології Kotlin, IoT рішення реалізовано на платі Arduino UNO R4 WIFI, з використанням датчиків відкриття та GPS-модуля за допомогою Arduino IDE та мови програмування C#. 
У результаті роботи здійснено програмну реалізацію системи відслідковування перевезення вантажів. Програмна система складається з веб-додатку, сервера, мобільного додатку та смарт-пристрою.


ЗМІСТ


Вступ	6
1 Аналіз та концептуальне моделювання предметної області	7
1.1	Бізнес-вимоги	7
1.1.1	Бізнес можливості	7
1.1.2	Бізнес-цілі та критерії успіху	8
1.1.3	Потреби клієнтів або ринку	9
1.1.4	Бізнес-ризики	10
1.2	Концепція рішення	10
1.2.1	Окреслення концепції	10
1.2.2	Головна функціональність	11
1.2.3	Припущення та залежності	13
1.3	Рамки та обмеження проєкту	14
1.3.1	Рамки первинного випуску	14
1.3.2	Рамки наступних випусків	15
1.3.3	Обмеження та винятки	16
1.4	Бізнес-контекст	16
1.4.1	Профілі зацікавлених сторін	16
1.4.2	Пріоритети проєкту	17
1.4.3	Робоче середовище	19
2	Постановка задачі	20
3	Проектування програмного проєкту	21
3.1	Проектування серверної частини проєкту	21
3.2	Проектування IoT частини проєкту	26
3.3	Проектування клієнтської частини проєкту	29
3.4	Проектування мобільного застосунку	34

4	Кодування програмного проєкту	38
4.1	Кодування серверної частини проєкту	38
4.1.1	Реалізація методу для пошуку найближчого контейнера	43
4.1.2	Реалізація методу для статистики	43
4.1.3	Реалізація методу для перевірки даних на коректність введення	44
4.1.4	Реалізація методу для резервного копіювання даних	45
4.2	Кодування розумного пристрою	45
4.2.1	Реалізація методу для зміни поточної температури, координат	46
4.2.2	Реалізація сторінки для відображення налаштувань IoT	46
4.3	Кодування клієнтської частини проєкту	47
4.3.1	Реалізація користувацького інтерфейсу	48
4.4	Кодування мобільного застосунку	55
4.4.1	Реалізація користувацького інтерфейсу	56
Висновки	71
Перелік джерел посилання	72
Додаток А	73
Додаток Б	81
Додаток В	89
Додаток Г	104
Додаток Д	117
Додаток Е	118


ВСТУП


Транспортна логістика відіграє ключову роль у сучасній економіці, забезпечуючи ефективне постачання товарів та матеріалів до місць їх призначення. Із зростанням глобалізації торгівлі та підвищенням вимог до швидкості та надійності доставки вантажів, потреба в ефективних системах відстеження перевезень стає все більш нагальною. Відслідковування вантажів дозволяє учасникам логістичного ланцюга мати актуальну інформацію про місцезнаходження та стан вантажу, що сприяє кращій координації та прийняттю обґрунтованих рішень.
Традиційні методи відстеження вантажів, такі як паперові документи та телефонні дзвінки, є трудомісткими, схильними до помилок та не забезпечують своєчасного доступу до інформації. Тому впровадження сучасних програмних систем для відслідковування перевезень стає необхідністю для підприємств, що прагнуть підвищити ефективність своїх логістичних операцій та задовольнити зростаючі очікування клієнтів.
Програмна система для відслідковування перевезення вантажів є комплексним рішенням, що інтегрує різноманітні технології, такі як системи глобального позиціонування (GPS), бездротові мережі передачі даних та веб-інтерфейси. Вона дозволяє в режимі реального часу відстежувати рух транспортних засобів, контролювати умови перевезення вантажів та забезпечувати своєчасне інформування всіх зацікавлених сторін про стан доставки.
У цій курсовій роботі буде розглянуто процес розробки програмної системи для відслідковування перевезення вантажів, включаючи аналіз вимог, проектування архітектури, вибір технологій та реалізацію ключових функціональних можливостей.

1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес можливості


Звісно, як і в будь-якій галузі, існує кілька конкурентів, які пропонують подібні послуги. Наприклад, в Україні -  компанія Navitrack  [1]. Цей сервіс дозволяє замовити готовий пристрій з GPS  трекером, де відбувається реєстрація важливих подій і вимірювань під час руху або стоянки автомобіля, такі як швидкість та часу на маршруті, моніторинг пересування в реальному часі.
Також, конкурентами є всі організації, котрі спеціалізуються в продажі готових GPS трекерів, вони можуть запропонувати більш низьку ціну за товар, але він не буде передбачувати можливість переглядати інформацію про падіння, або несанкціонований доступ до вантажу, формування звітності та статистик.  
Незважаючи на потенційну конкуренцію на ринку, ідея системи "CargoTrack" вигідно вирізняється своєю ефективністю та зручністю для користувачів. Адже вона буде мати не високу ціну, та можливість моніторингу параметрів в реальному часі та отримання звітів та статистик. "CargoTrack" має великі перспективи, оскільки вона буде актуальна до тих пір, поки буде актуальним перевезення, а воно в свою чергу буде актуальним завжди. За наявність  в ньому  унікальних функцій, його будуть використовувати частіше та з більшим задоволенням люди, які бажають спростити та збільшити якість перевезення вантажів!
Якщо говорити про монетизацію, то можуть бути декілька можливих способів, а саме:
	Підписка на платний план: Надання різних планів підписки для 
користувачів з різним додаванням можливостей формування звітів та статистик про стан вантажу під час перевезення, для покращення ефективності роботи.
	Партнерські програми: Створення партнерських програм з іншими 
компаніями, які пропонують пов'язані послуги (наприклад, сервіси доставленням вантажів, логістичні послуги) і отримання комісійних від наданих рекомендацій.
	Безпосередній продаж або оренда обладнання для індивідуального 
використання в логістичних компаніях та власників вантажів.


1.1.2	Бізнес-цілі та критерії успіху


Основні бізнес-цілі для цієї системи буде зосереджені на побудові якісної та зручної системи для людей, які бажають покращити ефективність перевезення вантажів. Серед важливих цілей можна виділити такі: 
ВО-1: Розширення команди, яка працює над проєктом, на 40% за перші 6 місяців.  
ВО-2: Побудова розвиненої сітки соціальних мереж, для збільшення лояльності користувачів та пізнаваності сервісу. Досягнення сумарної кількості підписників - 60 тисяч за перший рік функціонування.  
ВО-3: Досягнення середньої оцінки мобільного додатка в 4-5 зірок на платформах цифрової дистрибуції.  
ВО-4: Досягнення мінімальної кількості активних користувачів від 30 тисяч за перший рік.  
ВО-5: Забезпечити більш безпеку перевезення , що дозволить знизити кількість крадіжок під час доставки.  
 
Для оцінки успіху будуть використані три основні критерії, а саме: рівень охоплення ринку і популярність платформи, якість отриманого сервісу і реліз в заплановані терміни та прибутковість продукту. Також успішним проєкт буде вважатися, якщо він вийде на ринок в зазначені терміни без суттєвих зміщень строків виконання. Якість отриманого продукту повинна відповідати встановленим стандартам, а сервіс має працювати належним чином під різним навантаженням на мобільний додаток та сайт. Мірою успіху прибутковості буде повне покриття видатків та вихід на стабільний рівень прибутків із щорічним зростанням на рівні приблизно 20%. 


1.1.3	Потреби клієнтів або ринку 


Клієнти потребують систему, яка дозволяє в реальному часі відстежувати місцезнаходження вантажів та контролювати їх рух. Клієнти потребують зручного та інтуїтивно зрозумілого інтерфейсу для віддаленого моніторингу перевезення вантажу. Важливо мати можливість в режимі реального часу спостерігати за всіма параметрами та контролювати їх в заданих значеннях. 
Також ринок потребує систему, яка дозволить зменшити маніпуляціє під час перевезення з боку перевізника та зменшити впливу на довкілля. Клієнти потребують систему сповіщень , яка буде інформувати їх про будь-які аномалії або проблеми під час перевезення. Це допоможе вчасно реагувати на ситуації.
 На разі представлені на ринку системи не можуть задовольнити потреби клієнтів, адже люди не можуть переглядати віддалено інформацію про стан вантажу, а інші зручні функція відсутні, такі як перегляд статистики під час перевезення та отримання сповіщень про аномалії. 


1.1.4	Бізнес-ризики 


Як і в кожному бізнесі, у наші сфері є свої ризики. Для забезпечення конкурентоспроможності системи на ринку необхідно постійно інвестувати в дослідження та розробки нових технологій та функцій. Це може стати великим фінансовим обтяженням для компанії. Також збір та збереження великої кількості конфіденційної інформації про вантажі та їх рух створює ризик витоку даних. Недостатня захищеність може призвести до втрати довіри клієнтів та їх даних, а також до юридичних проблем. Також у світі може бути економічна нестабільність, а саме міни у економічному середовищі, такі як зростання вартості технологій або зміни валютних курсів, можуть негативно вплинути на фінансову стабільність компанії, зменшити попит користувачів на ринку і затримати розвиток системи


1.2	Концепція рішення
1.2.1	Окреслення концепції


Концепція "CargoTrack" - це система, яка поєднує клієнтську частину та мобільний застосунок для зручного та ефективного проведення процесу перевезення вантажів. Головна ідея за цією концепцією - надати користувачам засіб для контролю, моніторингу та оптимізації всіх аспектів перевезення, незалежно від їх досвіду та мети. Цільовою  аудиторією будуть логістичні компанії та власники вантажу, адже власників вантажу важливо мати можливість відстежувати місцезнаходження своїх вантажів та планувати їх перевезення, а для логістичних компаній важливо зменшити ризики на ушкодження вантажу під час перевезення та більш ефективно будувати шляхи для доставки вантажів.
Основні особливості концепції включають інтегровану систему "CargoTrack", яка об'єднує клієнтську частину і мобільний додаток в єдину систему, що дозволяє користувачам зручно взаємодіяти з нею через різні пристрої. Система надає засоби для відстежування процесу перевезення в реальному часі. Це містить контроль падіння, несанкціонованого доступу, швидкості руху, підтримки заданого маршруту та інші параметри, які важливі для успішної доставки вантажів. Користувачі можуть відстежувати параметри доставки в реальному часі через мобільний додаток або клієнтську, що забезпечує максимальну зручність та контроль над процесом. 
Загалом, концепція "CargoTrack" спрямована на спрощення та покращення процесу доставки для всіх зацікавлених користувачів, надаючи їм доступ до інструментів та можливостей для ефективного та успішного перевезення.


1.2.2	Головна функціональність


Базовими функціями клієнтської частини і мобільного застосунку є надання можливості швидко і зручно організування процес моніторингу переміщення вантажів для отримання максимального задоволення, також контролювання необхідних параметрів, таких як, місце перебування, швидкість руху, перевірка на падіння вантажу та несанкціонованого доступу до нього.  
Зі сторони веб-сайту:  
MF-1: Можливість реєстрації, створення особистого профілю.  
MF-2: Можливість додавати контейнери до свого профілю.  
MF-3: Можливість перегляду параметрів перевезення в реальному часі.  
MF-4: Можливість перегляду повного маршруту руху. 
MF-5: Отримання аналітичних даних та статистики щодо перевезення.
MF-6: Перегляд параметрів доступних датчиків.  
MF-7: Перегляд доступних для користувача контейнерів. 
MF-8: Придбання готової системи.  
MF-9: Служба підтримки - користувачі можуть звернутися до даної служби, якщо їм потрібна допомога фахівця.  
MF-10: Оформлення підписок, які наддадуть розлогу статистику та звіти.  
MF-11: Блокувати, видаляти, редагувати профілі користувачів.  
MF-12: Керування інформацією - адміністратор може виконувати стандартні CRUD операції.  
MF-13: Перегляд статистики системи - адміністратор може переглянути статистику і проаналізувати її. 
Зі сторони мобільного додатку:  
MF-14: Можливість реєстрації, створення особистого профілю.  
MF-15: Можливість додавати контейнери до свого профілю.  
MF-16: Можливість перегляду параметрів доставки в реальному часі.  
MF-17: Можливість перегляду маршруту руху вантажу. 
 MF-18: Отримання сповіщень та попереджень щодо проблем у процесі перевезення.  
MF-19: Перегляд доступних для користувача контейнерів
MF-20: Придбання готової системи.  
MF-21: Служба підтримки - користувачі можуть звернутися до даної служби, якщо їм потрібна допомога фахівця.  
MF-22: Перегляд стану датчиків. 
Зі сторони Розумного пристрою: 
MF-23: Контролювання параметрів руху, падіння вантажу та несанкціонованого доступу. 


1.2.3	Припущення та залежності


Припущення: 
1.	Припускається, що система буде вимушена зберігати велику кількість даних для кожного користувача. 
2.	Припускається, що користувачам буде зручно віддалено контролювати процес перевезення вантажів. 
3.	Припускається, що мобільний додаток буде доступний на популярних мобільних платформах. 
4.	Припускається, що користувачі системи будуть мати постійний доступ до інтернету та мати стабільне електропостачання. 
5.	Припускається, що датчики будуть мати постійний мати стабільне електропостачання та доступ до інтернету. 
Залежності: 
1.	Для коректної роботи системи необхідний сталий доступ до інтернету та електропостачання, адже система вимагає онлайн синхронізацію даних, що до параметрів перевезення. 
2.	Для забезпечення безпеки даних та вантажів важлива технічна підтримка та оновлення програмного забезпечення системи.
3.	Мобільний застосунок має бути дуже зручним, приємним візуально та інтуїтивно зрозумілим для користувачів. 
4.	Система повинна буди масштабованою. 
5.	Застосунок обов’язково має бути розміщеним на популярних мобільних платформах.  
6.	Потрібно дуже обережно та чітко працювати з безпекою даних перевезення, адже не дотримання правил збереження та обробки може призвести до витоку конфіденційної інформації та технологічні параметри.


1.3	Рамки та обмеження проєкту
1.3.1	Рамки первинного випуску


Сервіс має такі початкові головні функції для випуску продукту. 
Для веб-браузера: 
SIR-1: Реєстрація та авторизація користувача; 
SIR-2: Додавання контейнерів до свого профілю; 
SIR-3: Перегляд параметрів перевезення в реальному часі; 
SIR-4: Перегляд та отримання звітів та статистик, щодо перевезення вантажів; 
SIR-7: Перегляд повного маршруту руху; 
SIR-8: Перегляд доступних для користувача контейнерів; 
SIR-12: CRUD операції для адміністратора; 
SIR-13: Можливість блокувати та розблоковувати користувачів - функція для адміністратора; 
SIR-14: Перегляд статистики про сервіс - функція для адміністратора; 
Для мобільного застосунку: 
SIR-15: Авторизація користувача; 
SIR-16: Додавання контейнерів до свого профілю; 
SIR-17: Перегляд параметрів перевезення в реальному часі; 
SIR-18: Сповіщення та попередження що до проблем під час процесу перевезення; 
SIR-19: Перегляд повного маршруту руху; 
SIR-20: Перегляд доступних для користувача контейнерів; 
SIR-21: Придбання готової системи; 
SIR-22: Служба підтримки - користувачі можуть звернутися до даної служби, якщо їм потрібна допомога фахівця; 
SIR-23: Оформлення підписки, які надає доступ до розширеної статистики та звітів; 
SIR-24: Контролювання параметрів руху, падіння вантажу та несанкціонованого доступу.
Функції для Розумного пристрою:
SIR-25: Зчитування інформації з датчика GPS трекером, відкриття та падіння; 
SIR-26: Обробка інформації (зіставлення її з задовільними показниками) та надсилання результату до системи; 


1.3.2	Рамки наступних випусків


SSR-1: Розширення мов інтерфейсів та підтримки різних часових поясів; 
SSR-2: Збільшення додаткових датчиків контролю, такі як датчик температури та вологості, камера для спостерігання процесу доставки реальному часі; 
SSR-3: Впровадження штучного інтелекту та машинного навчання: Використання штучного інтелекту для прогнозування та оптимізації процесів перевезення вантажів;
SSR-4: Можливість замовлення систем безпосередньо у мобільному застосунку.
1.3.3	Обмеження та винятки


Обмеження: 
	LE-1: 	Система 	вимагає 	постійного 	інтернет 	підключення 	та 
електропостачання для коректної роботи застосунків; 
LE-2: Система не гарантує 100% цілісність вантажу під час доставки і не несе відповідальності за вантаж;
LE-4: Система буде підтримувати тільки дві основні мови це українська та англійська. 


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Логістичні компанії	Оптимізація маршрутів, зменшення витрат та підвищення ефективності перевезень	Розглядають 
систему як засіб полегшити контроль за вантажами та моніторинг доставки	Отримання реального часу та точної інформації про статус вантажу, можливість управління перевезеннями	Технологічні обмеження, високі витрати на впровадження


Кінець таблиці 1 
Власники вантажу	Підвищення надійності та швидкості доставки, зниження ризику втрат та затримок	Бачать систему як інструмент для забезпечення точності та надійності перевезення їх вантажу	Можливість відстеження місцезнаходження вантажу в реальному часі, отримання повідомлень про стан вантажу	Фінансові обмеження, потреба в навчанні персоналу
Регулюючі органи	Контроль за дотриманням правил перевезень та безпеки вантажів	Розглядають систему як інструмент для забезпечення дотримання вимог законодавства у сфері перевезень	Можливість отримання даних про перевезення для контролю та аналізу	Обмеження у доступі до даних, необхідність співпраці з іншими зацікавленими сторонами
Страхова компанія	Зменшення ризиків та витрат на відшкодування	Розглядають як можливість зменшення ризиків та витрат на відшкодування	Зменшення витрат на відшкодування, підвищення надійності перевезень	Обмежений доступ до даних, потреба в додаткових ресурсах для аналізу даних


1.4.2	Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту 
Показники	Виконання	Обмеження	Ступінь свободи
План роботи	Випуск 1.0 до 01.06.2024	Розробка серверної частини до 16.04.2024;
Розробка клієнтської частини до 30.04.2024;	Потрібно обов’язково виконати роботу до зазначеної дати.
Кінець таблиці 2
План роботи		Розробка мобільного додатку до 17.05.2024;
Розробка програмного забезпечення для Розумного пристрою до 30.05.2024;	.
Функціональність	Розробка зазначеного функціоналу з випуску 1.0 у серверній частині, клієнтської частині, мобільній частині та Розумний пристрій	Розробка до випуску 1.0	Усі найголовніші функції мають бути реалізовані у випуску 1.0
Якість	Тестування та виправлення помилок	Тестування та виправлення мають бути завершені до випуску 1.0	У випуску 1.0 допускається наявність лише невеликої кількості помилок, які не будуть мати вплив на загальну роботу системи і її функціонал
Персонал	Робота одного розробника	Лише один розробник повинен працювати над проєктом	Не допускається участь інших у створенні проєкту
Ціна	Є певний бюджет на створення проєкту	Бюджет є лімітом у витратах на розробку	Перевищення бюджету допустимо на 10%
1.4.3	Робоче середовище


Серверна частина буде розроблений мовою C# з використанням фреймворку ASP.NET. Для бази даних буду використовувати MongoDB, адже вона є NoSQL базою даних, яка надає гнучкість для зберігання та обробки даних у форматі JSON-подібних документів та підтримує цілісність даних, з можливістю створення резервних копій. Обрання мови C# для розробки серверної частини обумовлене її популярністю в середовищі .NET і багатими можливостями для розробки, також буде відбуватись шифрування необхідних даних.  
Клієнтська частина буде розроблений з використанням HTML, CSS і JavaScript, а саме використовуватиметься сучасна бібліотека React. Ці технології дозволять створити інтерактивний та сучасний веб-інтерфейс, який підтримується всіма сучасними браузерами, а головне підтримують високу безпеку вхідних та вихідних даних.  
Мобільний додаток буде розроблений на мові Kotlin. Kotlin є високорівневою мовою, що працює на платформі Java, що дозволяє використовувати багато з Java-фреймворків та бібліотек. Kotlin надає безпеку типів, що допомагає уникнути багатьох типових помилок під час компіляції.
Щодо розробки Розумного пристрою, будуть використовуватися платформа Arduino, адже вона надає простий спосіб створення для Розумного пристрою. Мова програмування С++, яка дозволяє легко розробляти програмне забезпечення для них та взаємодіяти з іншими технологіями та сервісами. 
Додатково буде під’єднано GPS трекером NEO-6M, датчики температури DHT22, датчики відкриття модуль магнетрон. Дані датчик зможуть забезпечити безпеку та цілісність вантажу під час доставки. 


2	ПОСТАНОВКА ЗАДАЧІ


Метою курсової роботи є проектування та розробка програмної системи для відстеження процесу транспортування вантажів різними видами транспорту. Система повинна бути розрахована на велику кількість користувачів та забезпечувати простий інтерфейс, зрозумілу структуру й навігацію.
Інтерфейс повинен бути інтуїтивним, реагувати на дії користувача без затримок, містити тільки необхідний функціонал для забезпечення потреб користувачів, а саме переглядати поточне місце перебування вантажу, створювати замовлення на перевезення, переглядати вхідні та вихідні вантажі.
Мати функціонал для  адміністраторів та логістів, а саме адміністративний функціонал повинен мати можливість перегляду даних користувачів, зміна ролей та блокування, розблокування облікових записів користувачів. Логіст має можливість створювати, змінювати, маршрут руху, розклад, приймати вантажі, переглядати різноманітні статистики про доставку для покращення послуг.
Система повинна мати можливість підтримки різних мови інтерфейсу, як клієнтської частини так і для системи адміністрування, а саме української та англійської мов.
Під час розробки були враховані існуючі проблеми та складена концептуальна модель предметної області - програмної системи для відстеження руху вантажів.


3	ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
3.1	Проектування серверної частини проєкту


Для ефективної розробки серверної частини важливо детально описати всі необхідні елементи для реалізації певного функціоналу. Для цього можна створити ER-модель даних, яка дозволить представити всі основні сутності та позначити зв’язки, які можуть встановлюватись між створеними сутностями. Після визначення всіх необхідних компонентів була розроблена відповідна ER-модель даних (див. рис. 1).
	Модель даних охоплює наступні компоненти та відповідні атрибути для них:
а) користувач, який має наступні поля: користувач_id, ім’я, прізвище, по_батькові, пароль, електронна_пошта, номер_телефон, ролі.
б) контейнер, який має наступні поля: тип, назва, вантажність, довжина, ширина, висота, поїздка_id, статус.
в) токен_оновлення, який має наступні поля: токен_id, токен, дата_кінця.
г) роль, яка має наступні поля:  роль_id, назва.
д) водій, який має наступні поля: водій_id, ім’я, прізвище, по_батькові, пароль, електронна_пошта, номер_телефон, номер_водійського_посвідчення.
к) вантаж, який має наступні поля: вантаж_id, назва, вага, оголошена_вартість, довжина, ширина, висота, ціна доставки, відомість_id, місто_відправки_id, адрес_відправки, місто_отримання_id, адрес_отримання.
л) місто, яке має наступні поля: місто_id, назва_міста, район, країна.
м) датчики, який має наступні поля: контейнер_id, датчик_id.
н) значення, яке має наступні поля: значення_id, датчик_id, значення, час_вимірювання.
п) датчик, який має наступні поля: датчик_id, тип, назва.
р) розклад, який має наступні поля: розклад_id, подорож_id, місто_id, час прибуття.
с) подорож, яка має наступні поля: подорож_id, машина_id, водій_id.
т) машина, яка має наступні поля: машина_id, номер_машини, бренд, вантажопідйомність.
у) відомість, яка має наступні поля: відомість_id, подорож_id, контейнер_id.
Кожна сутність має визначені поля для ефективної реалізації передбаченого функціоналу системи.
Після визначення всіх сутностей, наступним кроком є формування ключових сценаріїв використання програмної системи . Для досягнення цієї мети ідеально використовувати UML-діаграму прецедентів. Після ретельного аналізу функціоналу, було розроблено UML-діаграму прецедентів (див. рис. Д.1 у додатку Б). У визначеній UML-діаграмі прецедентів присутні п'ять акторів: гість, користувач, логіст, адміністратор та датчик. Кожен із цих акторів має доступ до раніше визначеного функціоналу. 
Зокрема, користувач може вносити зміни до своєї особистої інформації, переглядати інформацію про доставку, створення замовлення на перевезення вантажу згідно необхідних характеристик, зокрема переглядати місцезнаходження вантажу та історію його перевезення.
Гість має можливість зареєструватись, або авторизуватись у системі, але при цьому, він може тільки переглядати тарифи та інформацію про вантажоперевезення.
Логіст має можливість додавати, редагувати та видаляти інформацію про подорож, та розклад, знаходження найближчого контейнера. Також він має змогу формувати статистику по кількості перевезеного вантажу та вагу перевезеного вантажу. Логіст має доступ до загального функціоналу, який наявний у користувача.
Адміністратор має можливість внесення змін до будь-яких даних у базі даних та отримання необхідної інформації, створювати резервні копії. Він має доступ до функціоналу, який доступний логісту та користувачу.
Останнім актором є датчик, який має можливість змінювати поточного місця перебування, зміна статусу відкриття контейнера та зміна поточної температури.

 
Рисунок 1 – ER модель даних програмної системи "CargoTrack"

Деталі взаємодії серверної частини з іншими компонентами системи можна розглянути на UML-діаграмі розгортання. На цій діаграмі (див. рис. 2) показано, як сервер взаємодіє з різними компонентами, включаючи базу даних, клієнтські додатки та інші служби. Діаграма розгортання відображає фізичне розташування різних елементів системи та способи їхнього з'єднання, що допомагає зрозуміти загальну архітектуру системи та її функціональні можливості.
Отримання даних від IoT також буде реалізоване за допомогою REST API. Тому для  покращення розуміння взаємодії між IoT та серверною частиною була створена UML діаграма діяльності, адже вона представляє потоки робочого процесу або операцій в системі.

 
Рисунок 2 – UML діаграма розгортання програмної системи "CargoTrack"

Вона відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети (див.рис.3). Алгоритм має циклічний характер, тому розпочинається очікуванням протягом 20 секунд. Далі відбувається вимірювання поточних координат та температури, додатково відбувається перевірка на відкриття контейнера  за допомогою датчику, і результат відправляється POST-запитом до серверної частини.
Після отримання запиту серверною частиною  відбувається запис значень в базу даних. За допомогою даного алгоритму можна досягти максимальної якості отримання значень в реальному часі.

 
Рисунок 3 – UML діаграма діяльності програмної системи "CargoTrack"

	Додаток використовує чисту архітектуру (див. рис. 4). Унікальність цієї архітектури полягає в тому, як код організовано, щоб забезпечити низьку взаємозалежність компонентів, легкість тестування та модифікації. 
Ця архітектура дотримується принципів SOLID та централізує бізнес-логіку, відокремлюючи її від інтерфейсу користувача, бази даних та зовнішніх агентів. Даний додаток складається з 5 шарів.
Domain для зберігання сутностей переліків, всі інші шари використовують цей шар. Application має інтерфейси і DTO (Об'єкти передачі даних). 
Далі Persistence відповідає за доступ до бази даних і має реалізацію репозиторіїв. 
Шар Infrastructure відповідає за реалізацію сервісів. І останній, Api шар має контролери, що реалізують REST API інтерфейс.


Рисунок 4 – Схема чистої архітектури програмної системи "CargoTrack"


3.2	Проектування IoT частини проєкту


Головним кроком є формування ключових сценаріїв використання програмної системи . Для досягнення цієї мети ідеально використовувати UML-діаграму прецедентів. Після ретельного аналізу функціоналу, який був визначений у документі "Vision & Scope", було розроблено UML-діаграму прецедентів (див.  рис. 5). У визначеній UML-діаграмі прецедентів наявні три актори, а саме IoT, бізнес адміністратор, адміністратор. Кожен із цих акторів має доступ до раніше визначеного функціоналу. Зокрема, пристрій IoT може вимірювати температуру та координати, перевіряти статус відкриття. Адміністратор може фізично налаштовувати систему.
Бізнес-адміністратор має можливість налаштовувати параметри IoT системи, а саме змінювати одиницю вимірювання температури з Цельсія на Фаренгейт, та навпаки з Фаренгейта на Цельсій, також бізнес-адміністратор може змінювати затримку вимірювання температури і координат, переглядати цю затримку.

 
Рисунок 5 – UML діаграма прецедентів для IoT частини програмної системи "CargoTrack"

Тепер важливо визначити фізичні компоненти, що становлять частину Інтернету речей (ІоТ) системи. Для цього було створено діаграму компонентів з використанням мови моделювання UML (див. рис. 6). Аналізуючи діаграму компонентів можна сказати в ІоТ частині системи використовується мікроконтролер Arduino Uno Rev 4 WIFI. Інтегрований модуль WIFI надає можливість встановлювати з'єднання з мережею та взаємодіяти з віддаленими сервісами через бездротове підключення. Додатково до мікроконтролер було підключено датчик температури та GPS модуль, модуль магнетрон, який передаватиме отримані значення до основного мікроконтролера.

 
Рисунок 6 – UML діаграма компонентів для IoT частини програмної системи "CargoTrack"

Після визначення акторів та компонентів Інтернету речей (ІоТ) частини системи, наступним етапом є розробка діаграми взаємодії (див. рис. Д.2 у додатку Б), яка надає можливість переглянути процеси в програмному забезпеченні. ІоТ частина системи складається з одного пристрою та його датчика температури, GPS модуля, магнітний сенсор. 
Датчики передають числові значення програмному забезпеченню. Після цього відбувається відправка HTTP-запиту до серверної частини з метою запису поточної температури, координат та статусу відкриття після цього відбувається HTTP-запит до серверної частини на перевірку поточного та записаного значення, якщо значення відкриття контейнера відрізняється, відбувається зміна статусу відкриття (див.рис.1.7).  
Також в Інтернеті речей (ІоТ) частині системи передбачено сторінку налаштувань, на якій користувач може переглядати поточну затримку визначення температури, координат та статусу відкриття, змінювати затримку для даних датчиків та змінювати одиницю вимірювання значення температури та змінювати пароль для авторизації. 
Таким чином маємо більше гнучкості при використанні ІоТ. Для входу до сторінки налаштувань адміністратор повинен ввести логін та пароль, який за замовчуванням є "admin" та "1111" відповідно. 

 
Рисунок 7 – UML діаграма діяльності для ІоТ частини програмної системи "CargoTrack"


3.3	Проектування клієнтської частини проєкту


Для ефективної розробки клієнтської частини важливо детально описати всі необхідні елементи для реалізації певного функціоналу. Для досягнення цієї мети ідеально використовувати UML-діаграму прецедентів. Після ретельного аналізу функціоналу, який був визначений у документі "Vision & Scope", було розроблено UML-діаграму прецедентів (див. рис. Д.1 у додатку Д). У визначеній UML-діаграмі прецедентів присутні п'ять акторів: гість, користувач, логіст, адміністратор та датчик. Кожен із цих акторів має доступ до раніше визначеного функціоналу.  
Зокрема, користувач може вносити зміни до своєї особистої інформації, переглядати інформацію про доставку, створення замовлення на перевезення вантажу згідно необхідних характеристик, зокрема переглядати місцезнаходження вантажу та історію його перевезення.
Гість має можливість зареєструватись, або авторизуватись у системі, але при цьому, він може тільки переглядати тарифи та інформацію про вантажоперевезення.
Логіст має можливість додавати, редагувати та видаляти інформацію про подорож, та розклад, знаходження найближчого контейнера. Також він має змогу формувати статистику по кількості перевезеного вантажу та вагу перевезеного вантажу. Логіст має доступ до загального функціоналу, який наявний у користувача.
Адміністратор має можливість вносити зміни до будь-яких даних у базі даних та отримання необхідної інформації. Він має доступ до функціоналу, який доступний власнику та користувачу.
Після визначення акторів, потрібно пояснити, яким чином користувачі можуть отримати свою роль для цього було розроблено о UML діаграму станів ролі користувача (див. рис. 8). Для того, щоб отримати роль "Користувач" користувачу треба провести авторизація та реєстрацію, після чого дана роль буде автоматично додана. Для того щоб отримати роль "Адміністратор", треба щоб інший користувач, який має дану роль додав користувачу. Останнім є роль "Логіст", тобто це  користувач, який відповідає за прийняття замовлення, створення маршруту руху та відслідковувати вантаж під час перевезення Для того щоб отримати роль "Логіст", треба щоб інший користувач, який має роль "Адміністратор" додав користувачу.

 
Рисунок 8 – UML діаграма станів ролі користувача для клієнтської частини програмної системи "CargoTrack"

Наступним кроком була розроблена UML діаграма компонент (див. рис. 9), яка ілюструє взаємодію між ключовими компонентами програмної системи: клієнтською та серверною частинами. Ця діаграма надає докладну інформацію про основні компоненти, що знаходяться на стороні клієнта і відповідають за функціонування застосунку, враховуючи усі необхідні функціональні вимоги, які були визначені за допомогою UML діаграми прецедентів. 
Логіст  може створити рейс, розклад та відомість використовуючи кнопку на сторінці адміністрування логістики. Для адміністратора на даній сторінці має важливий функціонал, такий як перегляд користувачів, контейнерів, датчиків та інших сутностей, можливість створювати резервні копії таблиць бази даних у форматі CSV. 
Ключовим компонентом є кабінет, де користувач може отримати інформацію про вхідні та вихідні вантажі, відстеження місцеперебування, створити замовлення на доставку, редагувати власну інформацію, переглянути статистику. Цей компонент важливий для забезпечення користувачеві зручного способу взаємодії з системою, дозволяючи ефективно керувати перевезенням вантажів. Ця діаграма відображає компоненти, що відповідають за користувацький інтерфейс, обробку бізнес-логіки та взаємодію зовнішніми ресурсами та сервісами.

 
Рисунок 9 – UML діаграма компонентів для клієнтської частини програмної системи "CargoTrack"

Після визначення компонентів веб-додатка, розроблена діаграма діяльності користувача (див. рис. 10) надає уявлення про те, як користувачі можуть взаємодіяти з додатком.
По-перше, користувач має зареєструватися у додатку. Після цього він може переглядати інформацію про вхідні та вихідні вантажі та створити замовлення на перевезення. На сторінці доступних вантажів користувач зможе переглядати інформацію про актуальне місцезнаходження вантажу, перевірити статус. 
Логіст може прийняти вантаж, до перевезення, переглянути інформацію про рейс, розклад та переглянути статистику.
Адміністратор має доступ, щоб переглянути  дані користувача та редагувати їх, створення резервних.
Такий підхід забезпечує послідовність дій користувача та надає зручний інтерфейс для взаємодії з функціоналом веб-додатку, забезпечуючи при цьому конфіденційність і безпеку інформації.

 

Рисунок 10 – UML діаграма діяльності для клієнтської частини програмної системи "CargoTrack"

Після концептуального моделювання предметної області, клієнтський функціонал системи було формалізовано у вигляді чотирьох концептуальних моделей. На основі цих моделей можна переходити до етапу проектування архітектурних рішень та реалізації програмного забезпечення користувацького інтерфейсу. 


3.4	Проектування мобільного застосунку


Для ефективної розробки мобільного додатку важливо детально описати всі необхідні елементи для реалізації певного функціоналу. Для досягнення цієї мети ідеально використовувати UML-діаграму прецедентів. Після ретельного аналізу функціоналу, який був визначений у документі "Vision & Scope", було розроблено UML-діаграму прецедентів (див. рис. Д.1 у додатку Д). У визначеній UML-діаграмі прецедентів присутні п'ять акторів: гість, користувач, логіст, адміністратор та датчик. Кожен із цих акторів має доступ до раніше визначеного функціоналу.  
Зокрема, користувач може вносити зміни до своєї особистої інформації, переглядати інформацію про доставку, створення замовлення на перевезення вантажу згідно необхідних характеристик, зокрема переглядати місцезнаходження вантажу та історію його перевезення.
Гість має можливість зареєструватись, або авторизуватись у системі.
Логіст має можливість додавати, редагувати та видаляти інформацію про подорож, та розклад, знаходження найближчого контейнера. Також він має змогу формувати статистику по кількості перевезеного вантажу та вагу перевезеного вантажу. Логіст має доступ до загального функціоналу, який наявний у користувача.
Адміністратор має можливість внесення змін до будь-яких даних у базі даних та отримання необхідної інформації. Він має доступ до функціоналу, який доступний логісту та користувачу.
Після визначення акторів, потрібно пояснити, яким чином користувачі можуть отримати свою роль для цього було розроблено о UML діаграму станів ролі користувача (див. рис. 11). Для того, щоб отримати роль "Користувач" користувачу треба провести авторизація та реєстрацію, після чого дана роль буде автоматично додана. Для того щоб отримати роль "Адміністратор", треба щоб інший користувач, який має дану роль додав користувачу. Останнім є роль "Логіст", тобто це  користувач, який відповідає за прийняття замовлення, створення маршруту руху та відслідковувати вантаж під час перевезення Для того щоб отримати роль "Логіст", треба щоб інший користувач, який має роль "Адміністратор" додав користувачу.

 
Рисунок 11 – UML діаграма станів ролі користувача програмної системи "CargoTrack"

Наступним кроком була розроблена UML діаграма компонент [2], яка ілюструє взаємодію між ключовими компонентами програмної системи: мобільним додатком та серверною частинами (див. рис. 12). Ця діаграма надає докладну інформацію про основні компоненти, що знаходяться на стороні мобільного додатка і відповідають за функціонування застосунку, враховуючи усі необхідні функціональні вимоги, які були визначені за допомогою UML діаграми прецедентів. 
Логіст  може створити рейс, розклад та відомість використовуючи кнопку на сторінці адміністрування логістики. Для адміністратора на даній сторінці має важливий функціонал, такий як перегляд користувачів, контейнерів, датчиків та інших сутностей, можливість створювати резервні копії таблиць бази даних.
Ключовим компонентом  є кабінет, де користувач може отримати інформацію про вхідні та вихідні вантажі, відстеження місцеперебування, створити замовлення на доставку, редагувати власну інформацію, переглянути статистику. Цей компонент важливий для забезпечення користувачеві зручного способу взаємодії з системою, дозволяючи ефективно керувати перевезенням вантажів. Ця діаграма відображає компоненти, що відповідають за користувацький інтерфейс, обробку бізнес-логіки та взаємодію зовнішніми ресурсами та сервісами.

 
Рисунок 12 – UML діаграма компонентів мобільного додатку програмної системи "CargoTrack"

Після визначення компонентів мобільного додатку, розроблена діаграма діяльності користувача (див. рис. 13) надає уявлення про те, як користувачі можуть взаємодіяти з додатком.
По-перше, користувач має зареєструватися у додатку. Після цього він може переглядати інформацію про вхідні та вихідні вантажі та створити замовлення на перевезення. На сторінці доступних вантажів користувач зможе переглядати інформацію про актуальне місцезнаходження вантажу, перевірити статус. 
Логіст може прийняти вантаж, до перевезення, переглянути інформацію про рейс, розклад та переглянути статистику.
Адміністратор має доступ, щоб переглянути  дані користувача та редагувати їх, створення резервних. Такий підхід забезпечує послідовність дій користувача та надає зручний інтерфейс для взаємодії з функціоналом мобільного додатка, забезпечуючи при цьому конфіденційність і безпеку інформації.

 
Рисунок 13 – UML діаграма діяльності мобільного додатку програмної системи "CargoTrack"


4	КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1	Кодування серверної частини проєкту


Програмна Програмна система побудована на основі платформи .NET 7 з використанням ASP.NET Core для розробки серверної частини [3]. Це дозволяє створювати масштабовані та ефективні веб-сервіси, які відповідають принципам REST. 
Архітектурна модель MVC (Model-View-Controller) була обрана для цього проекту. Розділення на Model, View і Controller полегшує написання модульних тестів для кожного компонента окремо, що в свою чергу надає можливість легко додавати нові функції або змінювати існуючі, без значного впливу на інші частини системи. Контролери в ASP.NET Core використовуються для створення RESTful веб-сервісів. Вони забезпечують обробку HTTP-запитів та відповідають за взаємодію з базою даних через сервіси та репозиторії. Це дозволяє легко масштабувати систему та додавати новий функціонал. 
Для збереження даних використовується MongoDB, яка забезпечує надійне та швидке зберігання великих обсягів інформації. Вибір цієї бази даних обумовлений її високою продуктивністю, гнучкістю у зберіганні документів різних структур та здатністю ефективно обробляти великі обсяги інформації. MongoDB дозволяє легко масштабувати систему горизонтально, додаючи нові сервери до кластеру. 
Для комунікації між серверною частиною та клієнтськими додатками використовується REST API. Це дозволяє забезпечити уніфікований підхід до обміну даними та спрощує інтеграцію різних клієнтських платформ, таких як мобільні додатки та IoT-пристрої. REST API забезпечує стандартизовані способи доступу до ресурсів системи за допомогою HTTP-запитів.

Специфікація REST API наведена в таблиці 3 нижче.

Таблиця 3 – Специфікація REST API серверної частини системи
Сутність	Метод	Посилання	Дія
Користувач	GET	/users/all	Повернення список користувачів
		/users/{id}	Повернення користувача за ідентифікатором
	POST	/users/register	Реєстрація користувача
		/users/login	Вхід у систему
		/users/{id}/roles
{roleName}	Додавання ролі користувачу
	PUT	/users/update	Оновлення даних користувача
	DELETE	/users/{id}/roles
{roleName}	Видалення ролі користувача
		/users/{id}	Видалення користувача
Контейнер	GET	/container/all	Повернення всіх наявні контейнерів
		/container /find/{coordinates}	Повернення найближчих контейнерів, за координатами
		/ container /{id}	Повернення контейнера за його ідентифікатором
	POST	/ container /create	Створення контейнера
	PUT	/container/update	Оновлення даних про контейнер
		/container/
updateTrip	Оновлення подорожі для контейнера
	DELETE	/container /delete/{id}	Видалення контейнера



Продовження таблиці 3
Сутність	Метод	Посилання	Дія
Вантаж	GET	/cargo/sender/{id}	Повернення всіх вантажів 
відправника
		/cargo/receiver/{id}	Повернення всіх вантажів 
отримувача
		/cargo/{id}	Повернення інформації про 
вантаж
	POST	/cargo/create	Створення вантажу
	PUT	/cargo/update	Оновлення даних про вантаж
		/cargo/update/
container{id}	Оновлення номера контейнера  
	DELETE	/cargo/delete/{id}	Видалення вантажу
Місто	GET	/city/{id}	Повернення міста за його ідентифікатором
	POST	/city/create	Cтворення міста
	PUT	/city/update	Оновлення даних про 
налаштування
	DELETE	/city/delete/{id}	Видалення налаштування
Розклад	GET	/schedule/{id}	Повернення розкладу за його ідентифікатором
		/schedule/trip/{id}	Повернення розкладу за ідентифікатором подорожі
	POST	/schedule/create	Створення розкладу
	PUT	/schedule/update	Редагування даних розкладу
	DELETE	/schedule/delete/{id}	Видалення розкладу



Продовження таблиці 3
Сутність	Метод	Посилання	Дія
Датчик	GET	/sensor/all	Повернення всіх датчиків
		/sensor/{type}	Повернення датчиків за типом
	POST	/sensor/create	Створення датчика
	PUT	/sensor/update	Оновлення даних про датчик
	DELETE	/sensor/delete/{id}	Видалення датчику
Значення	GET	/value/sensor/{id}	Повернення значення 
за ідентифікатором датчика
		/value/sensor/{type}/ container/{id}	Повернення значення 
за типом датчика та за окремим контейнером
	POST	/value/create	Створення значення
	PUT	/value/update	Оновлення значення
	DELETE	/ value /delete/{id}	Видалення значення
Датчики	GET	/sensors	Повернення всі датчиків
		/sensors/container/{id}	Повернення всіх датчики для окремого контейнера
		/sensors/{type}/
container/{id}	Повернення окремого датчики для окремого контейнера за типом датчика
		/sensors/{id}/
container/{id}	Повернення окремого датчики для окремого контейнера
	POST	/sensors/create	Створення датчиків для 
контейнера
	PUT	/sensors/update	Оновлення датчиків для 
контейнера 
	DELETE	/sensors/delete/{id}	Видалення датчиків
Кінець таблиці 3
Сутність	Метод	Посилання	Дія
Водій	GET	/driver/{id}	Повернення користувача за ідентифікатором
	POST	/driver/create	Створення водія
	PUT	/driver/update	Оновлення даних водія
	DELETE	/driver/{id}	Видалення водія
Подорож	GET	/trip/{id}	Повернення подорожі
	POST	/trip/create	Створення подорожі
	PUT	/trip/update	Оновлення даних подорожі
	DELETE	/trip/{id}	Видалення подорожі
Машина	GET	/car/{id}	Повернення машини за його ідентифікатором
	POST	/car/create	Створення машини
	PUT	/car/update	Редагування даних машини
	DELETE	/car/delete/{id}	Видалення машини
Відомість	GET	/notice/{id}	Повернення відомості за його ідентифікатором
	POST	/notice/create	Створення відомості
	PUT	/notice/update	Редагування даних відомості
	DELETE	/notice/delete/{id}	Видалення відомості
Статистика	GET
	/statistics/delivery/
container	Повертає назву контейнера,  тип,  кількість подорожей, середня завантаженість, середній об’єм вантажу
		/statistics/trip{id}	Повертає загальний витрачений час, назву контейнера, тип, загальна вага, середня швидкість

4.1.1	Реалізація методу обробки даних для пошуку найближчого контейнера за координатами


При переході до конкретних реалізацій, було прийнято рішення розпочати з методу, що відповідає за ключовий функціонал системи – пошук найближчого контейнера за координатами. Основною задачею цього методу є отримання параметрів, метод приймає необхідні параметри для пошуку контейнера, а саме  координату довжини та координату ширини(див. рядок 3-18, розділ А.1 у додатку А). Далі відбувається автоматичне знаходження необхідного датчику і зчитування останні значення (див. рядок 5, розділ А.1 у додатку А). В результаті методу буде повернуто інформацію про контейнер, його координати, та відстань від місця пошуку.


4.1.2	Реалізація методу для статистики


Програмна система вкладає значну увагу в обробку статистичних даних, які становлять невід’ємну частину бізнес-логіки. Розглянемо статистику подорожі, а саме витрачений час, назву контейнера, його тип, загальна вага вантажу, середня швидкість руху 
Спочатку отримуються контейнер, який використовувався для перевезення (див. рядок 3-6, розділ А.2 у додатку А). Далі для  контейнера визначаємо назву, його тип (див. рядок 7-13, розділ А.2 у додатку А). Далі за допомогою запити дізнаємось загальну вагу вантажу, який був завантажений в даний контейнер, потім дізнаємось координати з початкового місця та місця прибуття (див. рядок 15-25, розділ А.2 у додатку А). Далі визначаємо відстань між даними місцями і ділимо на кількість часу, який був витрачений у даній подорожі. У кінці метод повертає статистику подорожі. Через те, що код зосереджений на отриманні та обробці даних щодо аналізу подорожі, його можна вважати частиною бізнес-логіки. Бізнес-логіка в даному випадку полягає в аналізі швидкості руху, кількості завантаженого вантажу та представленні статистики подорожі для прийняття рішень або отримання інформації.
Наступною статистикою є отримання інформації про контейнери, а саме перегляд його назви, тип, кількість подорожей, середня завантаженість, середній об’єм вантажу. Спочатку отримуємо інформацію про історію перевезення для заданого контейнера (див. рядок 3, розділ А.3 у додатку А). Далі для кожного контейнера визначаємо середню вагу та об’єм (див. рядок 7-58, розділ А.3 у додатку А). У кінці метод повертає сформований список статистики контейнера. Через те, що код зосереджений на отриманні та обробці даних щодо аналізу контейнерів, його теж  можна вважати частиною бізнес-логіки. Бізнес-логіка в даному випадку полягає в аналізі використання контейнерів для прийняття рішень та покращенням в майбутньому процесу перевезення. 


4.1.3	Реалізація методу для перевірки даних на коректність введення


Гарантування точності та правдивість вхідних даних є критичним завданням для забезпечення належного функціонування програмного забезпечення. Якщо введені користувачем дані не відповідають встановленим критеріям, це може призвести до виникнення винятків або помилок. 
Такі виключні ситуації мають бути належним чином оброблені програмним кодом, щоб забезпечити відповідну реакцію та запобігти некоректній поведінці системи. Наведений нижче фрагмент коду демонструє приклад реалізації процесу перевірки вхідних даних:

private async void ValidateEmailAddress(string email) { try   
{ 
MailAddress mailAddress = new MailAddress(email); 
} catch (FormatException) { 
throw new InvalidEmailException($"Неприпустима адреса електронної пошти: {email}"); 
} 
}


4.1.4	Реалізація методу для резервного копіювання користувацьких даних


Резервне копіювання стало життєво важливою практикою, адже постійно відбувається використання цифрової інформації. Непередбачувані події, такі як збій жорсткого диска, програмний збій, викрадення даних або людська помилка, можуть призвести до втрати даних. Тому було використано популярну бібліотеку "CsvHelper" і розроблено  метод ExportCsv, де відбувається зчитування інформації з колекції, після чого йде запис у файл (див. рядок 3, розділ А.3 у додатку А).


4.2	Кодування розумного пристрою


Технології для написання ІоТ частини були вибрані враховуючи функціональні потреби системи. Рішення про використання мікроконтролера Arduino призвело до обмежень щодо мови програмування [4], оскільки програмне забезпечення для Arduino розробляється на спеціалізованому діалекті C/C++. Для полегшення розробки ІоТ частини було вирішено використовувати бібліотеки: "TinyGPS", "ArduinoHttpClient", "WiFiS3", "DHT". Використання цих бібліотек дозволяє легко інтегрувати GPS-модулі, здійснювати HTTP-запити, підключатися до WIFI та працювати з датчиками температури і вологості.


4.2.1	Реалізація методу для зміни поточної температури, координат


Для переходу до конкретної реалізації було вирішено розпочати з методу, відповідального за основний функціонал ІоТ частини, а саме отримання температури, координат та зміну їх поточного значення. Основною метою цього методу є зміни поточної температури та координат для подальшого відстеження його на клієнтській частині. Цей метод викликається в циклічному методі loop, де він приймає значення у вигляді параметрів (див. рядок 32-36, розділ Б.1 у додатку Б), яке повернув безпосередньо датчик. Дана функція loop буде викликатись нескінченному циклі, поки не буде перервано електроживлення, або відбудуться подія, яка зупинить виконання даного методі. Після отримання результатів відбувається POST запит (див. рядок 63-88, розділ Б.1 у додатку Б), який записує значення.


4.2.2	Реалізація сторінки для відображення налаштувань IoT


Для забезпечення гнучкості конфігурації Інтернету ІоТ, була створена спеціальна сторінка налаштувань, яка дозволяє користувачам особисто адаптувати параметри системи під свої потреби, а саме затримка для зчитування значень з датчика температури та GPS модуля, даний функціонал є важливим, адже чим менше буде затримка, тим краще буде відбуватись процес відслідковування, але затримку треба регулювати під кожний тип задачі, даний метод можна викликаний кнопкою "Change Delay" на сторінці налаштувань. 
Зміна пароля для входу до сторінки налаштувань, а саме користувач може змінити пароль для підвищення безпеки системи (див. рядок 80-90, розділ Б.2 у додатку Б). Початковий логін "taras"  пароль "1111" шифрується (див. рядок 82, розділ Б.2 у додатку Б). Зміна паролю відбувається через локальний POST-запит, активований кнопкою "Change Password".
Зміна одиниці вимірювання температури, а саме користувач має можливість змінювати одиницю вимірювання температури  з Цельсія на Фаренгейт, та навпаки  з Фаренгейта на Цельсій (див. рядок 51-59, розділ Б.2 у додатку Б).
Крім налаштувань функціоналу, користувач може переглядати поточну затримку датчика. Сторінка налаштувань є важливим елементом Інтернету речей, забезпечуючи важливі можливості адаптації під конкретні умови використання.


4.3	Кодування клієнтської частини проєкту


В процесі розробки клієнтської частини веб-додатка, для виконання функціональних вимог та з урахуванням особистого досвіду, використовувався React разом з JavaScript. React відзначається фокусом на реактивному програмуванні для інтерфейсів користувача, при цьому не обмежуючи структуру всього додатку. Поєднання React та JavaScript дозволило отримати широкий функціонал та ефективність розробки веб-застосунків.
Для взаємодії з сервером та обміну даними була використана бібліотека Axios. Axios надає зручний і простий інтерфейс для виконання HTTP-запитів, що спрощує обробку асинхронних операцій та забезпечує ефективний обмін даними між клієнтом та сервером.
Для локалізації обрали бібліотеку "i18next", яка допомагає зробити додаток багатомовним. Вона дозволяє користувачам швидко перемикатися між мовами без перезавантаження сторінки. Це зручно і робить процес локалізації більш організованим і легким для підтримки в майбутньому. 
Для візуалізації та відображення графіків була використана бібліотека "PieChart". Ця бібліотека дозволяє легко і красиво побудувати різноманітні графіки та діаграми в інтерфейсі користувача, що сприяє кращому розумінню даних. Інтеграція Chart.js дозволила створити візуально привабливий та інформативний інтерфейс для відображення статистики та інших даних у додатку.


4.3.1	Реалізація користувацького інтерфейсу


Для отримання повного функціоналу додатку новий користувач повинен спочатку здійснити реєстрацію. Для цього йому достатньо натискати кнопку "Register" на навігаційній панелі (див. розділ В1 у додатку В). Після цього відкриється сторінка (див. рис. 14) з областями для введення даних. При введенні електронної пошти відбувається перевірка на правильність введених даних.
 
Рисунок 14 – Сторінка реєстрації програмної системи "CargoTrack"
Після успішної реєстрації користувач потрапляє на сторінку (див. рис. 15), де відображаються інформація про систему.

 
Рисунок 15 – Головна сторінка програмної системи ‘CargoTrack’

Після авторизації користувач може потрапити до сторінки кабінет, де наявна статистика користувача, перегляд вхідних та вихідних вантажів та безпосереднє створення замовлення на перевезення (див. рис. 16).

 
Рисунок 16 – Кабінет користувача програмної системи "CargoTrack"
При натисканні кнопки "Вхідні вантажі" користувач має сторінку з відображення вантажів та коротку інформацію про них, для детального ознайомлення необхідно обрати потрібний вантаж (див. рис. 17).

 
Рисунок 17 – Вхідні вантажі користувача програмної системи "CargoTrack"

На сторінці вантажу користувач може відстежити місцеперебування в реальному часі та переглянути повну інформацію про вантаж (див. рис. 18).

 
Рисунок 18 – Детальна інформація про вантаж користувача програмної системи "CargoTrack"
При натисканні кнопки "Створити замовлення на перевезення" користувач має сторінку з необхідними полями, які необхідно заповнити, для коректного створення вантажу (див. рис. 19).

 
Рисунок 19 – Створення замовлення на перевезення користувача програмної системи "CargoTrack"

		Після створення замовлення, користувач може переглянути створений вантаж в розділі "Вихідні вантажі", та відстежити його місцезнаходження і його статус (див. рис. 21).

 
Рисунок 21 – Вихідні вантажі користувача програмної системи "CargoTrack"
Користувач з роллю "Адміністратор" може здійснювати блокування, розблокування та редагування інформації користувачів на спеціальній сторінці (див. рис. 22-23). Додатково він може використовувати функцію пошуку за електронною поштою та номером елементу. Адміністратор має можливість робити копії даних, зокрема, копії таблиць, обираючи пункт "Створити резервну копію". Крім того, як і користувач з роллю "Логіст", адміністратор має право редагувати та видаляти вантажі, користувачів, датчики та контейнера, водіїв та автомобілі (див. розділ В2 у додатку В).

 
Рисунок 22 – Сторінка управлінням сутностями програмної системи "CargoTrack"

 
Рисунок 23 – Сторінка редагування сутностей програмної системи "CargoTrack"

Користувач з роллю "Логіст" може здійснювати пошук найближчих контейнерів від зони завантаження, для цього потрібно передати місце завантаження (див. рис. 24). Додатково користувач може переглянути номер контейнера та відстань від зони завантаження до фактичного місця перебування контейнера.

 
Рисунок 24 – Пошук найближчого  контейнера у програмній системі "CargoTrack"

На цій й ж сторінці логіст має список вантажів, які необхідно опрацювати, а саме створити рейс, розклад, та відомість, після чого призначити необхідну відомість вантажу, після чого вантаж зникне з списку (див. рис. 25-26)

 
Рисунок 25 – Сторінка опрацювання вантажів у програмній системі "CargoTrack"

 
Рисунок 26 – Модуль для введення інформації про рейс у програмній системі "CargoTrack"

Також логіст може переглянути необхідну статистику (див. розділ В3 у додатку В), а саме статистику використання контейнера, де відображається назва, тип контейнера, кількість виконаних подорожей та середня фактична та об’ємна вага перевезених вантажів (див. рис. 27)

 
Рисунок 27 – Статистика контейнерів у програмній системі "CargoTrack"

Також логіст може переглянути статистику рейсу, де відображається назва, тип контейнера, загальна вага, середня швидкість та кількість витраченого часу (див. рис. 28)

 
Рисунок 28 – Статистика виконаного рейсу у програмній системі "CargoTrack"


4.4	Кодування мобільного застосунку


У процесі розробки мобільного додатку на Kotlin у середовищі Android Studio [5], для реалізації функціональних вимог і з урахуванням власного досвіду, було використано кілька важливих інструментів і бібліотек. Kotlin забезпечує сучасний і ефективний підхід до розробки на Android, завдяки своїй лаконічності, безпеці та сумісності з Java.
Для виконання мережевих запитів та обміну даними з сервером використовувалась бібліотека "Retrofit2". Дана бібліотека надає зручний і простий інтерфейс для створення асинхронних HTTP-запитів, що значно спрощує процес взаємодії з RESTful API. Використання "Retrofit2" дозволяє зменшити кількість написаного коду та зробити його більш читабельним та підтримуваним.
Для візуалізації та відображення графіків у додатку була використана бібліотека "MPAndroidChart". Ця бібліотека надає великий набір можливостей для створення різноманітних діаграм і графіків, таких як лінійні, стовпчикові, кругові діаграми та інші. Вона забезпечує високу якість візуалізації даних та є легкою в інтеграції. 
Для створення графічного інтерфейсу використовувалась бібліотека "R". Вона надає широкий набір інструментів для розробки інтуїтивно зрозумілого та привабливого інтерфейсу користувача. Бібліотека "R" дозволяє створювати адаптивні та інтерактивні елементи інтерфейсу.
Використання цих інструментів дозволило створити сучасний, функціональний та візуально привабливий мобільний додаток, який відповідає всім вимогам користувачів.

4.4.1	Реалізація користувацького інтерфейсу


Для отримання повного функціоналу додатку новий користувач повинен спочатку здійснити реєстрацію. Для цього йому достатньо натискати кнопку "Register" (див. розділ Г1 у додатку Г). Після цього відкриється сторінка (див. рис. 29) з областями для введення даних. При введенні електронної пошти відбувається перевірка на правильність введених даних.

.  

Рисунок 29 – Сторінка реєстрації програмної системи "CargoTrack"

Після успішної реєстрації користувач потрапляє на сторінку (див. рис. 30), де відображаються інформація про систему.

 
Рисунок 30 – Головна сторінка програмної системи "CargoTrack"

Після авторизації користувач може потрапити до сторінки кабінет, перегляд вхідних та вихідних вантажів та безпосереднє створення замовлення на перевезення (див. рис. 31).
 
Рисунок 31 – Кабінет користувача програмної системи "CargoTrack"

При натисканні кнопки "Відправлені вантажі" користувач має сторінку з відображення вантажів та коротку інформацію про них, для детального ознайомлення необхідно обрати потрібний вантаж (див. рис. 32).

 
Рисунок 32 – Вхідні вантажі користувача програмної системи "CargoTrack"

На сторінці вантажу користувач може відстежити місцеперебування в реальному часі та переглянути повну інформацію про вантаж (див. рис. 33).
  
Рисунок 33 – Детальна інформація про вантаж користувача програмної системи "CargoTrack"

При натисканні кнопки "Створити замовлення на перевезення" користувач має сторінку з необхідними полями, які необхідно заповнити, для коректного створення вантажу (див. рис. 34).

 
Рисунок 34 – Створення замовлення на перевезення користувача програмної системи "CargoTrack"

		Після створення замовлення, користувач може переглянути створений вантаж в розділі "Вихідні вантажі", та відстежити його місцезнаходження і його статус (див. рис. 35).

 
Рисунок 35 – Вихідні вантажі користувача програмної системи "CargoTrack"


Користувач з роллю "Адміністратор" може здійснювати блокування, розблокування та редагування інформації користувачів на спеціальній сторінці (див. рис. 36-37). Додатково він може використовувати функцію пошуку за електронною поштою та номером елементу. Адміністратор має можливість робити копії даних, зокрема, копії таблиць, обираючи пункт "Створити резервну копію". Крім того, як і користувач з роллю "Логіст", адміністратор має право редагувати та видаляти вантажі, користувачів, датчики та контейнера, водіїв та автомобілі (див. розділ Г2 у додатку Г).

 
Рисунок 36 – Сторінка управлінням сутностями програмної системи "CargoTrack"

 
Рисунок 37 – Сторінка редагування сутностей програмної системи "CargoTrack"

Користувач з роллю "Логіст" може здійснювати пошук найближчих контейнерів від зони завантаження, для цього потрібно передати місце завантаження (див. рис. 38). Додатково користувач може переглянути номер контейнера та відстань від зони завантаження до фактичного місця перебування контейнера.

 
Рисунок 38 – Пошук найближчого  контейнера у програмній системі "CargoTrack"

На цій й ж сторінці логіст має список вантажів, які необхідно опрацювати, а саме створити рейс, розклад, та відомість (див. рис. 39).

 
Рисунок 39 – Сторінка опрацювання вантажів у програмній системі "CargoTrack"

На цій й ж сторінці логіст  може створити рейс, розклад, та відомість, після чого призначити необхідну відомість вантажу, після чого вантаж зникне з списку (див. рис. 40).

 
Рисунок 40 – Модуль для введення інформації про рейс у програмній системі "CargoTrack"

Також логіст може переглянути необхідну статистику (див. розділ Г3 у додатку Г), а саме статистику використання контейнера, де відображається назва, тип контейнера, кількість виконаних подорожей та середня фактична та об’ємна вага перевезених вантажів (див. рис. 41)

 
Рисунок 41 – Статистика контейнерів у програмній системі "CargoTrack"

Також логіст може переглянути статистику рейсу, де відображається назва, тип контейнера, загальна вага, середня швидкість та кількість витраченого часу (див. рис. 42)

 
Рисунок 42 – Статистика виконаного рейсу у програмній системі "CargoTrack"








ВИСНОВОК


У ході виконання курсової роботи було спроектовано та розроблено програмну систему для відстеження процесу транспортування вантажів різними видами транспорту. Система дозволяє значно полегшити та удосконалити логістику, підвищуючи якість перевезення вантажів, забезпечуючи доступ до функціоналу з будь-якого місця та у будь-який час.
Особлива увага була приділена розробці інтуїтивного та зручного інтерфейсу, який реагує на дії користувача без затримок і містить лише необхідний функціонал. Це дозволяє користувачам легко переглядати поточне місцезнаходження вантажу, створювати замовлення на перевезення, переглядати вхідні та вихідні вантажі.
Для адміністраторів та логістів розроблено окремий функціонал. Адміністратори мають можливість переглядати дані користувачів, змінювати ролі, блокувати та розблоковувати облікові записи. Логісти можуть створювати та змінювати маршрути руху, розклади, приймати вантажі та переглядати різноманітні статистичні дані про доставку, що сприяє покращенню послуг.
Система підтримує багатомовність, забезпечуючи інтерфейс як клієнтської частини, так і системи адміністрування українською та англійською мовами, що робить її доступною для ширшого кола користувачів.
У процесі розробки були враховані існуючі проблеми галузі та створена концептуальна модель предметної області. Завдяки цьому вдалося створити програмну систему, яка ефективно вирішує завдання відстеження руху вантажів, відповідаючи сучасним вимогам та потребам користувачів.



ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Про систему NaviTrack. URL: https://navitrack.com.ua/ (дата
звернення 19.03.2024)
2. Як будувати UML-діаграми.. URL: https://dou.ua/forums/topic/40575/
(дата звернення 10.05.2024)
3. Документація ASP.NET Core MVC URL:
https://learn.microsoft.com/uk-ua/aspnet/core/tutorials/first-mvc-app/startmvc?view=aspnetcore-5.0&tabs=visual-studio (дата звернення 02.06.2024)
4. Початок роботи з Arduino. URL: https://docs.arduino.cc/software/idev2/tutorials/getting-started-ide-v2/ (дата звернення 04.06.2024)
5. Базовий синтаксис Kotlin. URL: https://kotlinlang.org/docs/basicsyntax.html (дата звернення 05.04.2024)
6. Програмна реалізація. URL: https://github.com/NureBondarenkoTaras
/apzkr-pzpi-21-4-bondarenko-taras (дата звернення 08.06.2024)
7. Відеоматеріали реалізованого проєкту в YouTube. URL:
https://www.youtube.com/watch?v=vZXgvsjo6Hs (дата звернення 08.06.2024)


ДОДАТОК А
Код серверної частини
А.1 Код для  знаходження найближчого контейнера за координатами


1 public async Task<ContainerCoordinatesDto> FindContainer(string coordinatesX, string coordinatesY, CancellationToken cancellationToken)
2 {
3 var sensorGPS = await _sensorRepository.GetSensorByType("GPS",cancellationToken);
4 var sensors = await _sensorsRepository.FindSensorsByGPS(sensorGPS,cancellationToken);
5 var  values = await _valueRepository.GetLatestValueBySensorId(sensors, cancellationToken);
6 
7 // Початкові координати
8 double initialLat = Convert.ToDouble(coordinatesX);
9 double initialLon = Convert.ToDouble(coordinatesY);
10 
11 var nearestContainer = new ContainerCoordinatesDto();
12 double minDist = double.MaxValue;
13 
14 foreach (var value in values)
15 {
16 string[] coordinatesContainer = value.Coordinates.Split('/');
17 
18 double containerLat = Convert.ToDouble(coordinatesContainer[0]);
19 double containerLon = Convert.ToDouble(coordinatesContainer[1]);
20 
21 double dist = CalculateDistance(initialLat, initialLon, containerLat, containerLon);
22 
23 if (dist< minDist)
24 {
25 minDist = dist;
26 nearestContainer.ContainerId = value.ContainerId;
27 nearestContainer.Coordinates = value.Coordinates;
28 nearestContainer.Distance = minDist.ToString();
29 }
30 }
31 
32 return nearestContainer;
33 }
34 
35 static double CalculateDistance(double lat1, double lon1, double lat2, double lon2)
36 {
37 // Константа радіусу Землі в кілометрах
38 const double R = 6371;
39 
40 // Перетворення координат у радіани
41 lat1 = lat1 * Math.PI / 180;
42 lon1 = lon1 * Math.PI / 180;
43 lat2 = lat2 * Math.PI / 180;
44 lon2 = lon2 * Math.PI / 180;
45 
46 double dlon = lon2 - lon1;
47 double dlat = lat2 - lat1;
48 
49 // Формула гаверсинусів
50 double a = Math.Pow(Math.Sin(dlat / 2), 2) + Math.Cos(lat1) * Math.Cos(lat2) * Math.Pow(Math.Sin(dlon / 2), 2);
51 double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
52 
53 double distance = R * c;
54 
55 return distance;
56 }


А.2 Метод для отримання статистики про подорож


1 public async Task <TripUsageStatisticsDto> TripUsageStatistics(string tripId, CancellationToken cancellationToken)
2 {
3 var tripUsageStatistics = new TripUsageStatisticsDto();
4 var trip = await _tripRepository.GetOneAsync(c => c.Id == ObjectId.Parse(tripId), cancellationToken);
5 var notice = await _noticeRepository.GetContainer(tripId, cancellationToken);
6 var container = await _containerRepository.GetOneAsync(c => c.Id == notice.ContainerId, cancellationToken);
7 tripUsageStatistics.ContainerName = container.Name;
8 tripUsageStatistics.ContainerType = container.Type;
9 double time = 2;
10 var cargos = await _cargoRepository.GetCargoByNotice(notice.Id.ToString(), cancellationToken);
11 foreach (var cargo in cargos)
12 {
13 tripUsageStatistics.TotalWeight += cargo.Weight;
14 }15 var sensorGPS = await _sensorRepository.GetSensorByType("GPS", cancellationToken);
16 var sensors = await _sensorsRepository.FindSensorsByGPS(sensorGPS, cancellationToken);
17 var values = await _valueRepository.GetLatestValueBySensorId(sensors, cancellationToken);
18 var valuesnew = await _valueRepository.GetNewestValueBySensorId(sensors, cancellationToken);
19 double minDist = double.MaxValue;
20 double containerLat = double.MaxValue;
21 double containerLon = double.MaxValue;
22 double containerLat1 = double.MaxValue;
23 double containerLon1 = double.MaxValue;
24 foreach (var value in values)
25 {
26 if (value.ContainerId == (container.Id).ToString()) {
27 string[] coordinatesContainer = value.Coordinates.Split('/');
28     containerLat = Convert.ToDouble(coordinatesContainer[0]);
29     containerLon = Convert.ToDouble(coordinatesContainer[1]);
30 }
31 }
32 foreach (var value in valuesnew)
33 {
34 if (value.ContainerId == (container.Id).ToString())
35 {
36 string[] coordinatesContainer = value.Coordinates.Split('/');
37 containerLat1 = Convert.ToDouble(coordinatesContainer[0]);
38 containerLon1 = Convert.ToDouble(coordinatesContainer[1]);
39 }
40 }
41 double dist = CalculateDistance(containerLat1, containerLon1, containerLat, containerLon);
42 tripUsageStatistics.AverageSpeed = (dist/time).ToString();
43 return tripUsageStatistics;
44 }


А.3 Метод для отримання статистики про контейнер.



1 public async Task<ContainerUsageStatisticsDto> ContainerUsageStatistics(string containerId, CancellationToken cancellationToken)
2 {
3 var containerUsageStatisticsDto = new ContainerUsageStatisticsDto();
4 var container = await _containerRepository.GetOneAsync(c => c.Id == ObjectId.Parse(containerId), cancellationToken);
5 containerUsageStatisticsDto.ContainerId = container.Id.ToString();
6 containerUsageStatisticsDto.ContainerName = container.Name;
7 containerUsageStatisticsDto.ContainerType = container.Type;
8 // Отримання інформації про подорож
9 var numberTrip = await _noticeRepository.GetTripByContainerId(containerUsageStatisticsDto.ContainerId, cancellationToken);
10 containerUsageStatisticsDto.NumberTrips = numberTrip.Count;
11 
12 var cargos = await _cargoRepository.GetCargoByNotice(containerId, cancellationToken);
13 double cargoLength=0;
14 double cargoHeight=0;
15 double cargoWidth=0;
16 foreach (var cargo in cargos)
17 {
18 containerUsageStatisticsDto.AverageLoadCapacity += cargo.Weight;
19 }
20 containerUsageStatisticsDto.AverageLoadCapacity = containerUsageStatisticsDto.AverageLoadCapacity/containerUsageStatisticsDto.NumberTrips;
21 foreach (var cargo in cargos)
22 {
23 
24 cargoLength += cargo.Length;
25 cargoHeight += cargo.Height;
26 cargoWidth += cargo.Width;
27 }
28 var volumetricWeight = (cargoLength * cargoHeight * cargoWidth) / 4000;
29 containerUsageStatisticsDto.VolumetricWeight = volumetricWeight / containerUsageStatisticsDto.NumberTrips;
30 
31 return containerUsageStatisticsDto;
32 }


А.4 Метод для створення резервні копії бази даних


1 public class DataExportController : BaseController
2 {
3 private readonly DatabaseContext _dbContext;
4 
5 public DataExportController(DatabaseContext dbContext)
6 {
7 _dbContext = dbContext;
8 }
9 
10 [HttpGet("export_data/{collection_name}")]
11 public async Task<IActionResult> ExportData(string collection_name)
12 {
13 var data_collection = _dbContext.GetCollection(collection_name);
14 var raw_data = await data_collection.RetrieveData();
15 
16 // Підготовка файлу до експорту
17 var export_config = new FileExportConfig
18 {
19 Delimiter = ",",
20 Encoding = Encoding.UTF8
21 };
22 
23 using (var stream = new MemoryStream())
24 using (var writer = new StreamWriter(stream, Encoding.UTF8))
25 using (var file_writer = new FileWriter(writer, export_config))
26 {
27 foreach (var data_item in raw_data)
28 {
29 file_writer.WriteField(data_item.Serialize());
30 file_writer.NextRecord();
31 }
32 
33 writer.Flush();
34 stream.Position = 0;
35 return new FileResult(stream.ToArray(), "text/csv")
36 {
37 FileName = $"{collection_name}_export.csv"
38 };
39 }
40 }







ДОДАТОК Б
Код розумного пристроя
Б.1 Код для визначення температури та вологості, відправка отриманих параметрів на серверну частину


1. void loop() {
2. unsigned long currentMillis = millis();
3. 
4. // Перевірка наявності нового клієнта
5. WiFiClient currentClient = httpServer.available();
6. if (currentClient) {
7. Serial.println("New Client.");
8. String currentLine = "";
9. String httpRequest = "";
10. // Очікування з'єднання клієнта
11. while (currentClient.connected()) {
12. if (currentClient.available()) {
13. char c = currentClient.read();
14. Serial.write(c);
15. currentLine += c;
16. if (c == '\n') {
17. if (currentLine.length() == 2) {
18. processHttpRequest(currentClient, httpRequest);
19. break;
20. }
21. httpRequest += currentLine;
22. currentLine = "";
23. }
24. }
25. }
26. // Закриття з'єднання з клієнтом
27. currentClient.stop();
28. Serial.println("Client disconnected.");
29. Serial.println();
30. }
31. 
32. if (currentMillis - previousMillis >= measurementInterval) {
33. // Отримання значень координат з датчика NEO-6M
34. gps.f_get_position(&currentFlat, &currentFlon);
35. //Отримання значень температури з датчика DHT22
36. currentTemperature = DHT_Sensor.readTemperature(useFahrenheit);
37. // Отримання поточного часу
38. time_t t = now();
39. // Форматування часу у строку для використання в HTTP-     запиті
40. sprintf(formattedTimestamp, "%04d-%02d-%02dT%02d:%02d:%02d.717Z",
41. year(t), month(t), day(t), hour(t), minute(t), second(t));
42. // Вивід даних в консоль
43. Serial.println("-----------------------------");
44. Serial.print("GPS: ");
45. Serial.print("Flat: ");
46. print_float(currentFlat, TinyGPS::GPS_INVALID_F_ANGLE, 10, 6);
47. Serial.print(" Flon: ");
48. print_float(currentFlon, TinyGPS::GPS_INVALID_F_ANGLE, 11, 6);
49. Serial.print("Temperature: ");
50. Serial.println(currentTemperature);
51. Serial.print("MeasurementInterval: ");
52. Serial.println(measurementInterval);
53. Serial.print("useFahrenheit: ");
54. Serial.println(useFahrenheit);
55. Serial.println("-----------------------------");
56. sendPostRequest();
57. previousMillis = currentMillis;
58. }
59. }
60. void sendPostRequest() {
61. Serial.println("Sending POST requests...");
62. 
63. WiFiClient client;
64. if (client.connect(server, port)) {
65. Serial.println("Connected to server");
66. 
67. String postData = "{\"sensorId\":\"" + sensorIdTemperature + "\",\"values\":\"" + currentTemperature + "\",\"measurementTime\":\"" + formattedTimestamp + "\"}";
68. sendPostRequest(client, postData);
69. 
70. client.stop();  
71. 
72. // Повторне підключення
73. if (client.connect(server, port)) {
74. 
75. // Масив для зберігання форматованого рядка
76. char flonStr[16];
77. char flatStr[16]; 
78. // Форматування числа з крапкою в рядок з 6 знаками після коми
79. dtostrf(currentFlon, 1, 6, flonStr); 
80. dtostrf(currentFlat, 1, 6, flatStr); 
81. 
82. postData = "{\"sensorId\":\"" + sensorIdGPS + "\",\"values\":\"" + String(flatStr)+'/'+String(flonStr) + "\",\"measurementTime\":\"" + formattedTimestamp + "\"}";
83. sendPostRequest(client, postData);
84. 
85. // Закриття підключення
86. client.stop();  
87. Serial.println("POST requests sent");
88. } else {
89. Serial.println("Connection to server failed for the second POST request");
90. }
91. } else {
92. Serial.println("Connection to server failed for the first POST request");
93. }
94. }


Б.2 Метод для відображення налаштувань IoT


1 void sendSettingsPage(WiFiClient client) {
2 
3   /  // Перевірка автентифікації перед відправленням сторінки
4   if (!isAuthenticated) {
5     client.print("HTTP/1.1 302 Found\r\n");
6     client.print("Location: /\r\n");
7     client.print("\r\n");
8     return;
9   }
10 
11   // Виведення HTML-коду для сторінки SettingsPage
12   client.print("<!DOCTYPE html><html><head><title> SettingsPage</title>");
13   client.print("<style>");
14   // Стилі CSS для покращення вигляду сторінки
15   client.print("body { font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 0;}");
16   client.print("header { background-color: #333; color: #fff; text-align: center; padding: 1em; }");
17   client.print("form { max-width: 300px; margin: 2em auto; padding: 1em; background-color: #fff; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);}");
18   client.print("label { display: block; margin-bottom: 0.5em; }");
19   client.print("input { width: calc(100% - 12px); padding: 0.5em; margin-bottom: 1em; box-sizing: border-box; }");
20   client.print("input[type='submit'], input[type='button'] { background-color: #333; color: #fff; cursor: pointer;}");
21   client.print("p { margin-bottom: 1em; }");
22   client.print("form[id=\"temperatureUnitForm\"] label { display: inline; }");
23   client.print("</style>");
24   client.print("</head><body>");
25 
26   // Виведення заголовка сторінки
27   client.print("<header><h1>User settings</h1></header>");
28 
29   // HTML-форма для зміни паролю
30   client.print("<form id=\"passwordForm\">");
31   client.print("<label for=\"newPassword\">Change Password:</label>");
32   client.print("<input type=\"password\" id=\"newPassword\" name=\"newPassword\" required><br>");
33   client.print("<input type=\"button\" value=\"Change Password\" onclick=\"changePassword()\">");
34   client.print("</form>");
35 
36   // Виведення заголовка сторінки налаштувань сенсора
37   client.print("<header><h1>Sensor settings</h1></header>");
38 
39   // HTML-форма для зміни затримки
40   client.print("<form id=\"delayForm\">");
41   // Виведення поточної затримки
42   client.print("<p>Current measurement delay: ");
43   client.print(measurementDelay);
44   client.print(" milliseconds</p>");
45   // Елементи форми для введення нової затримки
46   client.print("<label for=\"newDelay\">Change Measurement Delay (in milliseconds):</label>");
47   client.print("<input type=\"number\" id=\"newDelay\" name=\"newDelay\" required><br>");
48   client.print("<input type=\"button\" value=\"Change Delay\" onclick=\"changeDelay()\">");
49   client.print("</form>");
50 
51   // HTML-форма для зміни одиниці вимірювання
52   client.print("<form id=\"temperatureUnitForm\">");
53   client.print("<label>Select Temperature Unit:</label>");
54   client.print("<input type=\"radio\" id=\"celsius\" name=\"temperatureUnit\" value=\"Celsius\" checked>");
55   client.print("<label for=\"celsius\">Celsius</label>");
56   client.print("<input type=\"radio\" id=\"fahrenheit\" name=\"temperatureUnit\" value=\"Fahrenheit\">");
57   client.print("<label for=\"fahrenheit\">Fahrenheit</label><br>");
58   client.print("<input type=\"button\" value=\"Change Temperature Unit\" onclick=\"changeTemperatureUnit()\">");
59   client.print("</form>");
60 
61   // JavaScript-код для зміни одиниць вимірювання температури
62   client.print("<script>");
63   client.print("function changeTemperatureUnit() {");
64   client.print("var selectedUnit = document.querySelector('input[name=\"temperatureUnit\"]:checked').value;");
65   client.print("var xhr = new XMLHttpRequest();");
66   client.print("xhr.open('POST', '/set-temperature-unit?selectedUnit=' + selectedUnit, true);");
67   client.print("xhr.send();");
68   client.print("}");
69   client.print("</script>");
70 
71   // JavaScript-код для зміни затримки
72   client.print("<script>");
73   client.print("function changeDelay() {");
74   client.print("var newDelay = document.getElementById('newDelay').value;");
75   client.print("var xhr = new XMLHttpRequest();");
76   client.print("xhr.open('POST', '/set-delay?newDelay=' + newDelay, true);");
77   client.print("xhr.send();");
78   client.print("}");
79 
80   // JavaScript-код для відправки нового паролю на сервер
81   client.print("function changePassword() {");
82   client.print("var hashedPassword = sha256(newPassword);");
83   client.print("var xhr = new XMLHttpRequest();");
84   client.print("xhr.open('POST', '/set-password?newPassword=' + newPassword, true);");
85   client.print("xhr.send();");
86   client.print("}");
87   client.print("</script>");
88 
89   client.print("</body></html>");
90 }


ДОДАТОК В
Код клієнтської частини
В.1 Код для реєстрації користувачів


1 import "./style.css"; 
2 import React, {useEffect, useState} from "react";
3 import axios from 'axios';
4 import login_photo_right from "./../../img/icon/login_photo_right.png";
5 import logo from "./../../img/icon/logo.png"; 
6 import google from "./../../img/icon/google.png"; 
7 import { userStore } from './../../Stores/UserStore';
8 import {useNavigate,useLocation} from 'react-router-dom';
9 
10 const  Login = () => { 
11 const navigate = useNavigate();
12 
13 const fetchUserData = async (userId) =>{
14 
15 var firstname=document.getElementById("firstname").value
16 var lastname=document.getElementById("lastname").value
17 var email=document.getElementById("email").value
18 var password=document.getElementById("password").value
19 var password_confirm=document.getElementById("confirm_password").value
20 
21 if(email.length>0 ||firstname.length>0||password.length>0||password_confirm.length>0||lastname.length>0){
22 
23 if(password===password_confirm){
24 try {
25 await userStore.registerUser(firstname, lastname, "", "", email, password);
26 navigate(`/login`);
27 } catch (error) {
28 console.error('Fetch user data error', error);
29 }
30 }
31 else{
32 alert("Паролі не однакові")
33 }
34 }
35 else{
36 alert("Ви не заповнили всі поля")
37 }
38 }
39 const location = useLocation();
40 var fragmentString = location.hash.substring(1);
41 
42 // Parse query string to see if page request is coming from OAuth 2.0 server.
43 var params = {};
44 var regex = /([^&=]+)=([^&]*)/g, m;
45 while (m = regex.exec(fragmentString)) {
46 params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
47 }
48 if (Object.keys(params).length > 0) {
49 localStorage.setItem('oauth2-test-params', JSON.stringify(params) );
50 if (params['state'] && params['state'] == 'try_sample_request') {
51 trySampleRequest();
52 }
53 }
54 
55 // If there's an access token, try an API request.
56 // Otherwise, start OAuth 2.0 flow.
57 function trySampleRequest() {
58 var params = JSON.parse(localStorage.getItem('oauth2-test-params'));
59 if (params && params['access_token']) {
60 var xhr = new XMLHttpRequest();
61 xhr.open('GET', 'https://www.googleapis.com/oauth2/v1/userinfo?access_token=' + params['access_token']);
62 xhr.onreadystatechange = function (e) {
63 if (xhr.readyState === 4 && xhr.status === 200) {
64 console.log(xhr.responseText);
65 } else if (xhr.readyState === 4 && xhr.status === 401) {
66 // Token invalid, so prompt for user permission.
67 oauth2SignIn();
68 }
69 };
70 xhr.send(null);
71 } else {
72 oauth2SignIn();
73 }
74 }
75 
76 /*
77 * Create form to request access token from Google's OAuth 2.0 server.
78 */
79 function oauth2SignIn() {
80 // Google's OAuth 2.0 endpoint for requesting an access token
81 var oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';
82 
83 // Create element to open OAuth 2.0 endpoint in new window.
84 var form = document.createElement('form');
85 form.setAttribute('method', 'GET'); // Send as a GET request.
86 form.setAttribute('action', oauth2Endpoint);
87 
88 // Parameters to pass to OAuth 2.0 endpoint.
89 var params = {
90 'scope': 'https://www.googleapis.com/auth/drive.metadata.readonly',
91 'state': 'try_sample_request',
92 'include_granted_scopes': 'true',
93 'response_type': 'token'};
94 
95 // Add form parameters as hidden input values.
96 for (var p in params) {
97 var input = document.createElement('input');
98 input.setAttribute('type', 'hidden');
99 input.setAttribute('name', p);
100 input.setAttribute('value', params[p]);
101 form.appendChild(input);
102 }
103 
104 // Add form to page and submit it to open the OAuth 2.0 endpoint.
105 document.body.appendChild(form);
106 form.submit();
107 }
108 
109 return ( 
110 
111 <main>
112 <div className="container">
113 <div className="font_right"><img src={login_photo_right} alt="Link" /> </div>
114 <div className="font_left"><img src={login_photo_right} alt="Link" /></div>
115 <div className="log_cont" >
116 <div className="login" >
117 <h3 className="hello">Welcome to CargoTruck</h3>
118 <div className="logo"><img src={logo} alt="Link" /></div>
119 
120 <input type ="text"  className="box" id="firstname" placeholder="Enter your first name"></input>
121 <input type ="text"  className="box" id="lastname" placeholder="Enter your last name"></input>
122 <input type ="text"  className="box" id="email" placeholder="Enter your email"></input>
123 <input  type ="text" className="box" id="password" placeholder="Enter your password"></input>
124 <input type ="text"  className="box" id="confirm_password" placeholder="Confirm Password"></input>
125 
126 <div className="or_line"> 
127   <div className="line1"></div><div className="text_or">or</div><div className="line2"></div>
128 </div>
129 <div className="login_button">
130   <button onClick={() => oauth2SignIn()} className="google_acc"><img className="foto_google" src={google} alt="Link" />Continue with Google</button>
131   <button href="./" onClick={fetchUserData} className="log">Register</button>
132   <div className="quest">Already have an account?<a href="./login" className="signup">Sign in</a></div>
133 </div>
134 </div>
135 </div>
136 
137 </div>
138 </main>
139 
140 );
141 }
142 
143 export default Login;


В.2 Код для адміністрування


1 import React, { useState, useEffect } from 'react';
2 import { userStore } from './../../Stores/UserStore';
3 import styles from './CargoList.module.css';
4 
5 const UserList = () => {
6 const [userDetails, setUserDetails] = useState([]);
7 const [selectedUser, setSelectedUser] = useState(null);
8 
9 // Function to fetch users from the store
10 const fetchUsers = async () => {
11 try {
12 await userStore.fetchUserPage();
13 setUserDetails(userStore.users);
14 } catch (error) {
15 console.error('Fetch user details error', error);
16 }
17 };
18 
19 // Fetch users on component mount
20 useEffect(() => {
21 fetchUsers();
22 }, []);
23 
24 // Function to handle editing or creating a user
25 const handleEditUser = async (user) => {
26 if (user.id) {
27 await userStore.updateUser(user);
28 } else {
29 await userStore.createUser(user);
30 }
31 fetchUsers();
32 };
33 
34 // Function to handle selecting a user for viewing/editing
35 const handleSaveUser = async (user) => {
36 try {
37 setSelectedUser(user);
38 await fetchUsers();
39 } catch (error) {
40 console.error('Save user error', error);
41 }
42 };
43 
44 // Function to handle banning a user
45 const handleBanUser = async (userId) => {
46 try {
47 await userStore.banUser(userId);
48 fetchUsers();
49 } catch (error) {
50 console.error('Ban user error', error);
51 }
52 };
53 
54 // Function to handle unbanning a user
55 const handleUnBanUser = async (userId) => {
56 try {
57 await userStore.unBanUser(userId);
58 fetchUsers();
59 } catch (error) {
60 console.error('Unban user error', error);
61 }
62 };
63 
64 return (
65 <div className={styles.container}>
66 {selectedUser && (
67 <div className={styles.form}>
68 <input
69 type="text"
70 value={selectedUser.firstName}
71 onChange={(e) => setSelectedUser({ ...selectedUser, firstName: e.target.value })}
72 placeholder="Ім'я"
73 />
74 <input
75 type="text"
76 value={selectedUser.lastName}
77 onChange={(e) => setSelectedUser({ ...selectedUser, lastName: e.target.value })}
78 placeholder="Прізвище"
79 />
80 <input
81 type="text"
82 value={selectedUser.patronym}
83 onChange={(e) => setSelectedUser({ ...selectedUser, patronym: e.target.value })}
84 placeholder="По-батькові"
85 />
86 <input
87 type="text"
88 value={selectedUser.phoneNumber}
89 onChange={(e) => setSelectedUser({ ...selectedUser, phoneNumber: e.target.value })}
90 placeholder="Телефон"
91 />
92 <input
93 type="email"
94 value={selectedUser.email}
95 onChange={(e) => setSelectedUser({ ...selectedUser, email: e.target.value })}
96 placeholder="Електронна пошта"
97 />
98 <input
99 type="text"
100 value={selectedUser.roles[0].name}
101 onChange={(e) => {
102 const roles = [...selectedUser.roles];
103 roles[0].name = e.target.value;
104 setSelectedUser({ ...selectedUser, roles });
105 }}
106 placeholder="Роль"
107 />
108 
109 <button onClick={() => handleEditUser(selectedUser)}>Зберегти</button>
110 </div>
111 )}
112 <ul className={styles.list}>
113 {userDetails.map(user => (
114 <li key={user.id} className={styles.item}>
115 <p>Ім'я: {user.firstName}</p>
116 <p>Прізвище: {user.lastName}</p>
117 <p>По-батькові: {user.patronym}</p>
118 <p>Телефон: {user.phoneNumber}</p>
119 <p>Електронна пошта: {user.email}</p>
120 <div>
121 <button onClick={() => handleSaveUser(user)}>Переглянути</button>
122 <button className={styles.del} onClick={() => handleBanUser(user.id)}>Заблокувати</button>
123 <button onClick={() => handleUnBanUser(user.id)}>Розблокувати</button>
124 </div>
125 </li>
126 ))}
127 </ul>
128 </div>
129 );
130 };
131 
132 export default UserList;


В.3 Код для статистики


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import './Statistics.css';
4 import { useTranslation } from 'react-i18next';
5 import NavBar from "../../Components/navbar/NavBar";
6 import Footer from "../../Components/footer/Footer"
7 import { statisticStore } from './../../Stores/StatisticStore';
8 import PieChart from '../../Components/PieChart/PieChart';
9 import BarChart from '../../Components/BarChart/BarChart';
10 
11 const Statistics = () => {
12 const { t } = useTranslation();
13 const [containerId, setContainerId] = useState('');
14 const [tripId, setTripId] = useState('');
15 const [containerStats, setContainerStats] = useState(null);
16 const [tripStats, setTripStats] = useState(null);
17 
18 // Fetch container statistics by ID
19 const fetchContainerStats = async (id) => {
20 try {
21 await statisticStore.getContainerStatistics(id);
22 setContainerStats(statisticStore.static);
23 } catch (error) {
24 console.error('Error fetching container statistics', error);
25 }
26 };
27 
28 // Fetch trip statistics by ID
29 const fetchTripStats = async (id) => {
30 try {
31 await statisticStore.getTripStatistics(id);
32 setTripStats(statisticStore.static);
33 } catch (error) {
34 console.error('Error fetching trip statistics', error);
35 }
36 };
37 
38 // Effect to fetch container statistics when containerId changes
39 useEffect(() => {
40 if (containerId) {
41 fetchContainerStats(containerId);
42 }
43 }, [containerId]);
44 
45 // Effect to fetch trip statistics when tripId changes
46 useEffect(() => {
47 if (tripId) {
48 fetchTripStats(tripId);
49 }
50 }, [tripId]);
51 
52 return (
53 <main>
54 <NavBar/>
55 <div className="statistics-container">
56 <h1>{t('Statistic.Statistics')}</h1>
57 
58 <div className="statistics-content">
59 <div className="statistics-column">
60 <div className="input-section">
61 <label htmlFor="containerId">{t('Statistic.Container ID')}:</label>
62 <input
63 type="text"
64 id="containerId"
65 value={containerId}
66 onChange={(e) => setContainerId(e.target.value)}
67 />
68 </div>
69 
70 {containerStats && (
71 <div className="stats-section">
72 <h2>{t('Statistic.Container Statistics')}</h2>
73 <p>{t('Statistic.Container ID')}: {containerStats.containerId}</p>
74 <p>{t('Statistic.Container Name')}: {containerStats.containerName}</p>
75 <p>{t('Statistic.Container Type')}: {containerStats.containerType}</p>
76 <p>{t('Statistic.Number of Trips')}: {containerStats.numberTrips}</p>
77 <p>{t('Statistic.Average Load Capacity')}: {containerStats.averageLoadCapacity}</p>
78 <p>{t('Statistic.Volumetric Weight')}: {containerStats.volumetricWeight}</p>
79 <div className="stati">
80 <PieChart 
81   averageLoadCapacity={containerStats.averageLoadCapacity}
82   volumetricWeight={containerStats.volumetricWeight}
83 />
84 </div>
85 </div>
86 )}
87 </div>
88 
89 <div className="statistics-column">
90 <div className="input-section">
91 <label htmlFor="tripId">{t('Statistic.Trip ID')}:</label>
92 <input
93 type="text"
94 id="tripId"
95 value={tripId}
96 onChange={(e) => setTripId(e.target.value)}
97 />
98 </div>
99 
100 {tripStats && (
101 <div className="stats-section">
102 <h2>{t('Statistic.Trip Statistics')}</h2>
103 <p>{t('Statistic.Trip ID')}: {tripStats.tripId}</p>
104 <p>{t('Statistic.Container Name')}: {tripStats.containerName}</p>
105 <p>{t('Statistic.Container Type')}: {tripStats.containerType}</p>
106 <p>{t('Statistic.Total Weight')}: {tripStats.totalWeight}</p>
107 <p>{t('Statistic.Average Speed')}: {tripStats.averageSpeed}</p>
108 <p>{t('Statistic.Time Spent')}: {tripStats.timeSpent}</p>
109 <div className="stati">
110 <BarChart 
111   totalWeight={tripStats.totalWeight}
112 />
113 </div>
114 </div>
115 )}
116 </div>
117 <Footer/>
118 </main>
119 );
120 };
121 
122 export default Statistics;


ДОДАТОК Г
Код мобільного додатка
Г.1 Код для реєстрації користувачів


1 class RegisterActivity : AppCompatActivity() {
2 
3 var isAuth = false;
4 
5 override fun onCreate(savedInstanceState: Bundle?) {
6 super.onCreate(savedInstanceState)
7 setContentView(R.layout.activity_register)
8 
9 val userEmail: EditText = findViewById(R.id.registerEmail)
10 val userPassword: EditText = findViewById(R.id.registerPassword)
11 val userFirstName: EditText = findViewById(R.id.registerFirstName)
12 val userLastName: EditText = findViewById(R.id.registerLastName)
13 val button: Button = findViewById(R.id.registerButton)
14 val linkoToRegistration: TextView = findViewById(R.id.userLogin)
15 
16 button.setOnClickListener {
17 val email = userEmail.text.toString().trim()
18 val password = userPassword.text.toString().trim()
19 val firstName = userFirstName.text.toString().trim()
20 val lastName = userLastName.text.toString().trim()
21 
22 if (lastName.isEmpty() || firstName.isEmpty() || email.isEmpty() || password.isEmpty()) {
23 Toast.makeText(this, "Не всі поля заповнені", Toast.LENGTH_LONG).show()
24 } else {
25 val user = UserCreate(firstName, lastName, "", "", email, password)
26 registerUser(user)
27 if(isAuth){
28 val intent = Intent(this, AuthActivity::class.java)
29 startActivity(intent)
30 }
31 }
32 }
33 
34 linkoToRegistration.setOnClickListener{
35 
36 val intent = Intent(this, AuthActivity::class.java)
37 startActivity(intent)
38 }
39 }
40 
41 private fun registerUser(user: UserCreate) {
42 
43 GlobalScope.launch(Dispatchers.Main) {
44 try {
45 val response = RetrofitClient.userService.registerUser(user)
46 if (response.isSuccessful) {
47 Toast.makeText(this@RegisterActivity, "Success", Toast.LENGTH_LONG).show()
48 isAuth = true;
49 } else {
50 val errorMessage = response.errorBody()?.string() ?: "Unknown error occurred"
51 
52 // Перевірка, чи помилка містить "Invalid email"
53 if (errorMessage.contains("System.ArgumentException: Invalid email")) {
54 Toast.makeText(this@RegisterActivity, "The mail was entered in the wrong format", Toast.LENGTH_LONG).show()
55 } else {
56 Toast.makeText(this@RegisterActivity, "Error: $errorMessage", Toast.LENGTH_LONG).show()
57 }
58 }
59 } catch (e: Exception) {
60 Toast.makeText(this@RegisterActivity, "Error: ${e.message}", Toast.LENGTH_LONG).show()
61 }
62 }


Г.2 Код для адміністрування


1 class AdminActivity : AppCompatActivity() {
2 
3 private lateinit var btnUser: Button
4 private lateinit var btnCargo: Button
5 private lateinit var entityListView: ListView
6 private lateinit var btnCreateBackup: Button
7 private lateinit var entity: String
8 
9 override fun onCreate(savedInstanceState: Bundle?) {
10 super.onCreate(savedInstanceState)
11 setContentView(R.layout.activity_admin)
12 
13 btnUser = findViewById(R.id.btnUser)
14 btnCargo = findViewById(R.id.btnCargo)
15 entityListView = findViewById(R.id.entityListView)
16 btnCreateBackup = findViewById(R.id.btnCreateBackup)
17 
18 btnUser.setOnClickListener {
19 fetchUsers()
20 }
21 btnCargo.setOnClickListener {
22 fetchCargo()
23 }
24 btnCreateBackup.setOnClickListener {
25 createBackup(entity)
26 }
27 }
28 
29 private fun fetchUsers() {
30 lifecycleScope.launch(Dispatchers.Main) {
31 try {
32 val users = RetrofitClient.userService.getUser()
33 entity = "User"
34 displayUsers(users.items)
35 Log.d("Cargo", "Data fetched successfully: ${users.items.size} items")
36 } catch (e: Exception) {
37 Log.e("Error", "Failed to fetch cargo: ${e.message}")
38 }
39 }
40 }
41 
42 private fun fetchCargo() {
43 lifecycleScope.launch(Dispatchers.Main) {
44 try {
45 val cargo = RetrofitClient.cargoService.getCargoPage()
46 entity = "User"
47 displayCargo(cargo.items)
48 Log.d("Cargo", "Data fetched successfully: ${cargo.items.size} items")
49 } catch (e: Exception) {
50 Log.e("Error", "Failed to fetch cargo: ${e.message}")
51 }
52 }
53 }
54 
55 private fun displayUsers(users: List<UserDto>) {
56 val adapter = UserAdapter(
57 this,
58 users,
59 onBlockClick = { userId -> blockUser(userId) },
60 onUnblockClick = { userId -> unblockUser(userId) }
61 )
62 entityListView.adapter = adapter
63 entityListView.visibility = View.VISIBLE
64 btnCreateBackup.visibility = View.VISIBLE
65 }
66 private fun displayCargo(cargo: List<Cargo>) {
67 val adapter = CargoAdapter(
68 this,
69 cargo,
70 onSelectClick = { cargoItem -> selectCargo(cargoItem) }
71 )
72 entityListView.adapter = adapter
73 entityListView.visibility = View.VISIBLE
74 btnCreateBackup.visibility = View.VISIBLE
75 }
76 private fun selectCargo(cargoId: String) {
77 // Implement logic for cargo selection if needed
78 Toast.makeText(this, "Selected cargo with ID: $cargoId", Toast.LENGTH_SHORT).show()
79 }
80 private fun blockUser(userId: String) {
81 
82 lifecycleScope.launch(Dispatchers.Main) {
83 try {
84 val users = RetrofitClient.userService.banUser(userId)
85 } catch (e: Exception) {
86 Log.e("Error", "Failed to fetch cargo: ${e.message}")
87 }
88 }
89 
90 
91 Toast.makeText(this, "Blocked user with ID: $userId", Toast.LENGTH_SHORT).show()
92 }
93 
94 private fun unblockUser(userId: String) {
95 // Implement the logic to unblock the user here
96 Toast.makeText(this, "Unblocked user with ID: $userId", Toast.LENGTH_SHORT).show()
97 
98 lifecycleScope.launch(Dispatchers.Main) {
99 try {
100 val users = RetrofitClient.userService.unBanUser(userId)
101 } catch (e: Exception) {
102 Log.e("Error", "Failed to fetch cargo: ${e.message}")
103 }
104 }
105 }
106 
107 private fun createBackup(entity: String) {
108 lifecycleScope.launch(Dispatchers.IO) {
109 try {
110 val responseBody = RetrofitClient.exportService.downloadBackup(entity)
111 val file = saveFile(responseBody, "backup_$entity.csv")
112 
113 launch(Dispatchers.Main) {
114 if (file != null) {
115 Toast.makeText(this@AdminActivity, "File saved: ${file.absolutePath}", Toast.LENGTH_LONG).show()
116 Log.d("Backup", "File saved at: ${file.absolutePath}")
117 } else {
118 Toast.makeText(this@AdminActivity, "Failed to save file", Toast.LENGTH_SHORT).show()
119 }
120 }
121 } catch (e: Exception) {
122 Log.e("Error", "Failed to create backup: ${e.message}")
123 }
124 }
125 }
126 
127 private fun saveFile(body: ResponseBody, fileName: String): File? {
128 return try {
129 val filePath = File(getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), fileName)
130 var inputStream : InputStream ? = null
131 var outputStream : OutputStream ? = null
132 
133 try {
134 inputStream = body.byteStream()
135 outputStream = FileOutputStream(filePath)
136 
137 val fileReader = ByteArray(4096)
138 var fileSizeDownloaded: Long = 0
139 
140 while (true) {
141 val read = inputStream.read(fileReader)
142 if (read == -1) {
143 break
144 }
145 
146 outputStream.write(fileReader, 0, read)
147 fileSizeDownloaded += read
148 }
149 
150 outputStream.flush()
151 filePath
152 } catch (e: Exception) {
153 Log.e("Error", "Error saving file: ${e.message}")
154 null
155 } finally {
156 inputStream?.close()
157 outputStream?.close()
158 }
159 } catch (e: Exception) {
160 Log.e("Error", "Error saving file: ${e.message}")
161 null
162 }
163 }
164 }


Г.3 Код для статистики


1 class ContainerStatisticsActivity : AppCompatActivity() {
2 
3 private lateinit var pieChart: PieChart
4 
5 override fun onCreate(savedInstanceState: Bundle?) {
6 super.onCreate(savedInstanceState)
7 setContentView(R.layout.activity_container_statistics)
8 
9 // Знаходимо EditText, TextView та PieChart у макеті
10 val containerIdInput: EditText = findViewById(R.id.containerIdInput)
11 val containerNameTextView: TextView = findViewById(R.id.containerName)
12 val containerTypeTextView: TextView = findViewById(R.id.containerType)
13 val numberTripsTextView: TextView = findViewById(R.id.numberTrips)
14 
15 
16 val pieChart: PieChart = findViewById(R.id.pieChart)
17 
18 // Обробник подій для автоматичного пошуку даних
19 containerIdInput.addTextChangedListener(object : TextWatcher {
20 override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
21 
22 override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
23 val containerId = s.toString()
24 if (containerId.isNotEmpty()) {
25 // Виклик функції для отримання даних
26 fetchContainerStatistics(containerId, containerNameTextView, containerTypeTextView, numberTripsTextView, pieChart)
27 }
28 }
29 
30 override fun afterTextChanged(s: Editable?) {}
31 })
32 }
33 
34 private fun fetchContainerStatistics(
35 containerId: String,
36 containerNameTextView: TextView,
37 containerTypeTextView: TextView,
38 numberTripsTextView: TextView,
39 pieChart: PieChart
40 ) {
41 lifecycleScope.launch(Dispatchers.Main) {
42 try {
43 // Виконуємо запит до сервера
44 val response = RetrofitClient.statisticsService.getContainerStatistics(containerId)
45 
46 // Встановлюємо текст у TextView
47 containerNameTextView.text = "Container Name: ${response.containerName}"
48 containerTypeTextView.text = "Container Type: ${response.containerType}"
49 numberTripsTextView.text = "Number of Trips: ${response.numberTrips}"
50 
51 
52 // Створення списку для PieEntry
53 val entries = ArrayList<PieEntry>()
54 entries.add(PieEntry(response.averageLoadCapacity.toFloat(), "Load Capacity"))
55 entries.add(PieEntry(response.volumetricWeight.toFloat(), "Volumetric Weight"))
56 
57 // Створення DataSet і PieData
58 val dataSet = PieDataSet(entries, "Container Statistics")
59 
60 // Налаштування кольорів для кожного значення
61 val colors = listOf(Color.RED, Color.BLUE)
62 dataSet.colors = colors
63 
64 // Зміна кольору тексту значень
65 dataSet.valueTextColor = Color.BLACK
66 
67 // Задання розміру тексту значень
68 dataSet.valueTextSize = 18f
69 val data = PieData(dataSet)
70 
71 // Налаштування PieChart
72 pieChart.data = data
73 pieChart.description.isEnabled = false
74 pieChart.invalidate() // Оновлення діаграми
75 
76 } catch (e: Exception) {
77 Toast.makeText(this@ContainerStatisticsActivity, "Container not found", Toast.LENGTH_SHORT).show()
78 clearChart(pieChart)
79 clearTextViews(containerNameTextView,
containerTypeTextView,numberTripsTextView)
80 }
81 }
82 }
83 
84 private fun setupPieChart(containerData: Container) {
85 val entries = listOf(
86 PieEntry(containerData.averageLoadCapacity.toFloat(), "Average Load Capacity"),
87 PieEntry(containerData.volumetricWeight.toFloat(), "Volumetric Weight")
88 )
89 
90 val dataSet = PieDataSet(entries, "Container Statistics")
91 val data = PieData(dataSet)
92 pieChart.data = data
93 pieChart.invalidate() // Оновлює діаграму
94 }
95 private fun clearChart(pieChart: PieChart) {
96 pieChart.clear()
97 }
98 
99 private fun clearTextViews(vararg textViews: TextView) 
100 textViews.forEach { it.text = "" }
101 


ДОДАТОК Д
Перевірка на плагіат

Рисунок Д.1 – Результат перевірки на плагіат
 
ДОДАТОК Е
Діаграми

Рисунок Е.1 – UML діаграма прецедентів програмної системи "CargoTrack"
 
Рисунок Е.2 – UML діаграма взаємодії у програмному забезпеченні для ІоТ програмної системи "CargoTrack"
